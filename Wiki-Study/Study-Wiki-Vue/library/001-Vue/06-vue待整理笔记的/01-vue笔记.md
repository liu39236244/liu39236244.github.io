Vue.js的学习笔记

| 一、什么是Vue.js                                                  |
|-------------------------------------------------------------------|
| 二、框架和库的区别三、Node（后端）中的mvc和前端中的mvvm自检的区别 |

1.  Vue基本语法

2.  、基本用法

3.  、v-cloak，v-text命令的使用

4.  、v-bind命令

5.  ，v-on指令

6.  跑马灯案例

7.  事件修饰符

8.  、.stop：阻止事件冒泡

9.  、.prevent ：阻止默认事件

10. 、.capture ：捕获触发事件发生的机制

11. 、.self : 只有操作的对象是自己的时候才触发事件

12. 、.once : 值触发一次事件处理函数

13. 、.self 和 .stop阻止事件冒泡的区别

七、v-model

八、使用v-model实现简易计算器

九：通过属性绑定指令v-bind给元素添加class样式

| 十、通过属性绑定指令：v-bind绑定内联样式 |
|------------------------------------------|
| 十一：v-for指令的四种使用方式            |

1.  使用v-for指令遍历普通数组

2.  使用v-for指令遍历字符串数组

3.  使用v-for指令遍历对象数组

4.  使用v-for指令遍历对象

5.  使用v-for迭代数字

十二、v-if和v-show指令的使用

1.  VUE中过滤器filter的定义和使用

2.  Vue中全局过滤器的定义语法：

3.  私有过滤器的定义

4.  过滤器调用语法：

5.  品牌列表实例

6.  Vue为Dom元素绑定键盘事件

7.  Vue提供的键盘事件修饰符：

8.  Vue中自定义全局按键修饰符

9.  自定义指令

10. 定义全局指令

11. 自定义私有指令

12. 自定义指令简写

13. Vue实例的生命周期

14. 生命周期介绍

十九、添加全局配置

>   1、使用全局配置，配置请求地址的根路径（域名）

| 2、全局配置，启用标单提交时的emulationJSON=true |
|-------------------------------------------------|
| Vue中组件的使用                                 |

1.  组件的概念

2.  组件化和模块化的不同

3.  Vue中定义全局组件（公三种方式，推荐使用第三种）

>   第一种：三步骤

>   第二种： 直接使用Vue.component()来进行定义

>   第三种：使用ID引入模板的方式进行定义

1.  Vue中使用components定义私有组件

2.  私有组建中的data和methods

3.  组件切换

4.  父子组件之间传值

5.  子组件调用父组件方法

6.  父子组件数据和方法调用-品牌案例

7.  Vue中使用ref属性获取dom元素二十二、Vue中的路由（Route）

8.  什么是路由

9.  在Vue中使用vue-route

10. 路由的简单使用

11. 路由（VueRouter）中的参数传递

12. 路由（VueRouter）传值第一种方式

13. 路由纯质第二种方式

14. 路由（VueRouter）嵌套

15. 使用路由实现经典布局

| 二十三、Vue中的watch属性             |
|--------------------------------------|
| 使用keyup方法实现名称案例            |
| 10.3、webpack处理.scss类型的样式文件 |
| 11、webpack处理图片和字体的url路径   |

16. 使用Vue实例中的watch属性改造名称案例3、使用watch属性检测路由的变化

>   二十四、Vue中computed（计算属性）属性

>   1、computed、methods、watch三者对比

二十五、webpack

1.  nrm

2.  镜像

3.  nrm使用的使用

4.  webpack的使用

>   4.1、问题引入

>   4.2、webpack介绍

>   4.3、webpack的两种安装方式

>   4.4、使用webpack构建项目

>   4.5、webpack的作用

1.  webpack配置文件的基本使用（webpack.config.js）

2.  webpack-dev-server工具的使用

3.  webpack-dev-server工具常用的命令参数

4.  webpack-dev-server工具配置命令参数的第二种方式（了解即可）

5.  webpack插件html-webpack-plugin配置启动页面

6.  webpack处理样式文件

>   10.1、webpack处理.css类型的文件

>   10.2、webpack处理.less类型的样式文件

一、什么是Vue.js
================

Vue是目前 火的一个前端框架；React是
流行的一个前端框架（React除了开发网站，还可以开发手机App）。

Vue是一套构建用户界面的框架，只关注于视图层。他不仅易上手，还便于和第三方的库或既有项目进行整合。Vue有配套的第三方类库，可以整合起来做大型项目的开发。

>   提高开发效率的发展历程：原生JS--\>Jquery之类的类库--\>前端模板引擎--

\>Angular.js/Vue.js(能够帮我们减少不必要DOM操作，提高浏览器页面渲染效率。双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要去关心数据的业务逻辑，不再关心DOM是如何渲染的了】)。

在Vue.js中，一个核心的概念，就是让用户不再操作DOM元素，解放了程序员的双手，让程序员可以更多的区关注业务逻辑。

二、框架和库的区别
==================

框架：是一套完成的技术解决方案；对我们项目的侵入性比较大；项目如果需要更换框架，则需要重新架构整个项目。

库（插件）：提供某一小功能，对项目的侵入性比较小，如果某个库无法完成某些需
mvc和前端中的mvvm自检的区别

四、Vue基本语法
===============

>   （1）、基本用法

![](media/3a18792f938dfd18d8725235abca07ee.png)

| methods:{ //在这里定义好方法，然后才使用v‐on指令绑定 |
|------------------------------------------------------|
| \</                                                  |

1.  show:function(data){

2.  alert(data);

3.  }

4.  } 49 });

50script\>

1.  、v-cloak，v-text命令的使用

>   1、使用v-cloak能够解决网速慢时插值表达式闪烁的问题。

>   2、v-text和插值表达式{{}}的区别

1.  、默认v-text是没有网速慢闪烁的问题

2.  、v-text会覆盖元素中原本的内容，但是插值表达式{{}}智慧替换自己的占位符，不会吧整个元素的内容清空

>   3、v-html 也会覆盖元素内的所用内容，但是v-html可以解析html字符串。

![](media/a7f80bb8f97c6193df03a8e479610508.jpg)

1.  、v-bind命令

>   v-bind是Vue中提供的绑定属性的指令

>   同时：v-bind会将引号内的内容视为js代码，myTitle + "123"为一个变量

\+字符串，属于合法js代码，因此v-bind也可以解析

![](media/74dc4bcd2e3f439c8814501089beec1a.jpg)

>   v-bind命令可以被简写为英文冒号 :+要绑定的属性

![](media/ace08c8777ad9316a1783c363ac36e75.jpg)

1.  ，v-on指令

Vue中提供了v-on事件绑定指令：通过v-on就可以给Dom元素绑定执行的
method，前提是该method必须已经在methods中定义好了。

![](media/f487a85c11fc816e7cf9bf67cc65f3a6.jpg)

>   v-on指令可以缩写为\@符号，\@+需要绑定的事件名称

![](media/960dd7295087caefef991bf8cc89edfb.jpg)

五、跑马灯案例
==============

注意：

1.  、在Vue实例中，想要获取data中的某一属性值 或者
    调取methods中的某一个方法，必须通过this.属性名称 或者
    this.方法名称来进行访问调取。这里的this代表的就是new出来的Vue实例。

2.  、Vue实例会监听自己身体上data中的所有属性值的变化，只要数据一发生变化，vue就会自动将
    新的数据渲染到DOM元素中去展示。好处：程序员只用操心数据，不用关心如何渲染dom页面。

3.  、嵌套函数：嵌套函数内部的this和嵌套函数外部的this使用保持一致，不用再去操心this对象的改变。

| \<script src = './lib/vue.js' |
|-------------------------------|


    1.  \<body\>

        >   3

| \<!‐‐ |
|-------|


    2.  通过插值表达式{{}}

        1.  \<div id="app"\>

| \<!‐‐ |
|-------|


    3.  通过v‐on(\@)

        1.  \<input type="button" 8 \<input type="button"

            >   9

            1.  \<h4 v‐cloak\>{{content

| \</ |
|-----|


    4.  div\>

        >   12

        1.  \<script type="text/javascript"

            1.  /\*注意：在Vue实例中，想获取

            2.  必须通过this.属性名称

            3.  这里的this就代表我们

            >   17

            1.  Vue实例会监听自己身上的会自动将

            2.  新的数据渲染到DOM 渲染DOM页面

| \*/ |
|-----|


    >   20

    \>\</

    script\>

| ‐‐\> |
|------|
| ‐‐\> |
| /\>  |

    value = '浪起来' \@click="lang2"

| /\> |
|-----|


    value = "停止" \@click="stop"

| \</ |
|-----|


    } h4\>

    \>

    data中的某一数据或者调取methods中的某一个方法，

    或者 this.方法名称来进行访问。出来的Vue实例

    data中的属性值的改变，只要数据一发生变化，vue
    对象中去展示，好处：程序员只用关心数据，不用关心如何

|   | 取值 指令绑定点击事件 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|---|-----------------------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


>   }

new

就

![](media/c5bf36d61b6e8d42f8d716f729c14ad7.png)

| 61 } 62 }); |
|-------------|
| \</         |
| \</         |

63script\>

64body\>

六、事件修饰符
==============

1.  、.stop：阻止事件冒泡

![](media/966cef8f06f9d23095a2f1222f2c4d19.jpg)

1.  、.prevent ：阻止默认事件

![](media/cd27c01376ddaf10b3bb12a5bbd02073.jpg)

1.  、.capture ：捕获触发事件发生的机制

![](media/f11a78b43a5744682455344aa81fd860.jpg)

1.  、.self : 只有操作的对象是自己的时候才触发事件

![](media/faf0230f981e3812edd6e161b11c1f65.jpg)

1.  、.once : 值触发一次事件处理函数

![](media/4905569e8b19c7800e8425b3a7e1fc5f.jpg)

1.  、.self 和 .stop阻止事件冒泡的区别

>   .self
>   修饰只是阻止元素自己身上的冒泡行为被触发，并不是真正的阻止了整个冒泡行为。

.stop 修饰符是从根本上真正阻止了冒泡行为的产生。

七、v-model
v-model：使用v-model指令可实现表单元素的数据的双向绑定注意：v-model指令只能运用于表单元素中。例如：input、radio、select、

checkbox等

| \<script src="./lib/vue.js" |
|-----------------------------|


1.  \<body\>

    1.  \<div id="app"\>

| \</ |
|-----|


    2.  \<h4\>{{msg}} h4\>

| \<!‐‐ |
|-------|


    3.  v‐bind 向绑定

        1.  无法实现数据的双向绑定

| ‐‐\> |
|------|


    >   7

    >   8 \<!‐‐ \<input type=

| /\> |
|-----|


    >   0%;" ‐‐\>

    >   9

| \<!‐‐ |
|-------|


    1.  使用v‐model

        1.  注意：v‐model

            1.  input[radio xtarea等

| ‐‐\> |
|------|


    >   13

    1.  \<input type="text" model="msg" style="width:100%;"

| \</ |
|-----|


    2.  div\>

        >   16

        1.  \<script\>

            1.  var vm = new Vue(

            2.  el: "\#app",

            3.  data: {

            4.  msg: "使用

            5.  },

            6.  methods: {

            >   24

            >   25 } 26 })

| \</ |
|-----|


    >   27 script\>

| \</ |
|-----|


    >   28body\>

    \>\</

    script\> 指令只能实现数据的单向绑定，从M（model） 到 V（view）的单

    >   v‐bind:value = "msg" style = "width: 10

    实现表单元素的数据的双向绑定

    指令只能运用于表单元素上

    >   checkbox、text、button、address]、select、te

    name="vModel" id="vModel" v /\>

    v‐model指令实现数据的双向绑定！！！！"

|   | "text" |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|---|--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


>   、

{

八、使用v-model实现简易计算器
=============================

| \<option value = "+" |
|----------------------|


1.  \<option value = "‐"

    1.  \<option value = "\*" 9 \<option value = "/"

| \</ |
|-----|


    2.  select\>

        1.  \<input type="text" name

            1.  \<input type="button"

            2.  \<input type="text" name

| \</ |
|-----|


    3.  div\>

        1.  \<script\>

            1.  var vm = new Vue({

            2.  el: "\#app",

            3.  data: {

            4.  num1: 0,

            5.  num2: 0,

            6.  result: 0,

            7.  opt: "+"

            8.  },

            9.  methods: {

            10. doAdd(){ //

            11. /\*

            12. 普通写法

            13. switch(this

            14. case

            15. this his.num2);

            >   31

            1.  case

            2.  this his.num2);

            >   34

            1.  case

            2.  this his.num2);

            >   37

            1.  case

            2.  this his.num2);

            >   40

            >   41 } \*/

            >   42

        \>+\</

        option\> option\> option\> option\> "num2" id="num2" v‐model="num2" /\>

| /\> |
|-----|


    ="=" \@click="doAdd"

|         | \>‐\</ |                                       |     |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|---------|--------|---------------------------------------|-----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| \>\*\</ |        |                                       |     |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
| \>/\</  |        |                                       |     |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|         |        | "result" id="result" v‐model="result" | /\> |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|         |        |                                       |     |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|         |        |                                       |     |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |

>   =

value

>   =

执行计算

.opt "+": .

break; "‐": .

break; "\*": .

break; "/": . break;

>   ){

result = parseInt(this.num1) + parseInt

result = parseInt(this.num1) ‐ parseInt

result = parseInt(this.num1) \* parseInt

result = parseInt(this.num1) / parseInt

>   2 \<body\> (

>   (

>   (

| //简便写法 使用eval()函数 |
|---------------------------|
| \</                       |
| \</                       |

1.  var resultStr = "parseInt(this.num1)" + this.opt + eInt(this.num2)";

2.  this.result = eval(resultStr);

3.  }

4.  } 48 })

script\>

50body\>

( "p 九：通过属性绑定指令v-bind给元素添加class样式
==================================================

![](media/2140b5f1b002334492e8fa00feeeff61.png)

| \</ \<h1 v‐bind:class="['red','italic']"\>使用属性绑定指令：v‐bind绑定cl ass样式 h1\> 30 |                                                         |      |
|------------------------------------------------------------------------------------------|---------------------------------------------------------|------|
| \<!‐‐                                                                                    |                                                         |      |
| ‐‐\>                                                                                     |                                                         |      |
| \<!‐‐                                                                                    |                                                         |      |
| ‐‐\>                                                                                     |                                                         |      |
| \<!‐‐                                                                                    |                                                         |      |
| ‐‐\>                                                                                     |                                                         |      |
| \</                                                                                      |                                                         |      |
| \<!‐‐                                                                                    | 5、第五种方法：直接将对象定义在data中，然后传递对象名称 | ‐‐\> |
| \</                                                                                      |                                                         |      |
| \</                                                                                      |                                                         |      |
| \</                                                                                      |                                                         |      |
| \</                                                                                      |                                                         |      |

1.  1、第二种方式，是使用三元表达式

2.  如下：通过判定data中flag属性的值，来确定是否添加italic样式

33

\<h1 v‐bind:class="['red', flag?'italic':'']"\>使用属性绑定指令：v‐b
ind绑定class样式\</h1\>

35

1.  3、第三种方式：传入对象

2.  如下：在数组中传入对象{'active':
    flag}，通过data中flag属性的值，来确定是否添加active样式

38

\<h1 v‐bind:class="['red', 'italic', {'active': flag}
]"\>使用属性绑定指令：v‐bind绑定class样式\</h1\>

40

1.  4、第四种方法：直接传入对象，数组都不需要

2.  如下：直接给class属性绑定一个对象{'属性名1' : 变量值1, '属性名 2' : 变量值2
    }

3.  通过data中变量的值的变化，来控制属性的添加与否

44

\<h1 v‐bind:class="{'active': flag,'red': flag, 'thin' : flag}"\>
用属性绑定指令：v‐bind绑定class样式h1\>

46

47

1.  \<h1 v‐bind:class="classObj"\>使用属性绑定指令：v‐bind绑定class样式 h1\>

2.  div\>

50

1.  \<script\>

2.  var vm = new Vue({

3.  el: "\#app",

4.  data: {

5.  flag: true,

6.  classObj: { 'active': true, 'red': true, 'thin': true }

7.  },

8.  methods: { }

9.  });

10. script\>

61body\>

使十、通过属性绑定指令：v-bind绑定内联样式
==========================================

| \<script src="./lib/vue.js" |
|-----------------------------|


1.  \<body\>

    1.  \<div id="app"\>

| \<!‐‐ |
|-------|


    >   4

    >   5

    >   6

| ‐‐\> |
|------|


    >   7

| \<!‐‐ |
|-------|


    1.  1,

| \</ |
|-----|


    2.  \<h1 :style = 为元素绑定内联样式 h1\>

        >   10

        >   11

| \<!‐‐ |
|-------|


    3.  2,

| \</ |
|-----|


    4.  \<h1 :style = 元素绑定内联样式 h1\>

        >   14

| \<!‐‐ |
|-------|
| ‐‐\>  |

    5.  3,第三种方式：在上

        1.  \<h1 :style =

| \</ |
|-----|


    6.  \<h1 :style = 样式 h1\>

| \</ |
|-----|


    7.  div\>

        1.  \<script\>

            1.  var vm = new Vue(

            2.  el: "\#app",

            3.  data: {

            4.  styleObj124 styleObj2

            5.  },

            6.  method: { }

            7.  });

| \</ |
|-----|


    8.  script\>

        \>\</

        script\> 内联样式就是指设置在元素本身上的样式
        注意：如果样式名是单纯的单词，则可不加引号。

        >   ‐），则必须使用引号将样式名也括起来

| ‐‐\> |
|------|


    第一种方式：传递一个数组，在数组中放入样式对象

    "[{color: 'red','font‐weight':200}]"\>使用属性绑定指令

| ‐‐\> |
|------|


    第二种方式：直接传递样式对象，数组都不需要

    "{color: 'red','font‐weight':200}"\>使用属性绑定指令为

    data中定义样式对象，然后将对象名绑定到style属性

| \</ |
|-----|


    >   \>使用属性绑定指令为元素绑定内联样式h1\>

    "[styleObj1,styleObj2]"\>使用属性绑定指令为元素绑定内联

    color: 'red','font‐weight':200},

    'font‐style':'italic'}

|   | 如果样式名中含有短横杠（ "styleObj1" { : { : { |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|---|------------------------------------------------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


十一：v-for指令的四种使用方式
=============================

注意：不论在遍历数组还是遍历对象时，索引index或者key都

写在后面，值或者value都写在前面。即：v-for="(item,i) in array"
或者v-for="(val,key) in obj"

1.  使用v-for指令遍历普通数组

| 1                                         | \<!‐‐ | 使用v‐for遍历普通数组 | ‐‐\> |   |
|-------------------------------------------|-------|-----------------------|------|---|
|                                           |       |                       |      |   |
|                                           |       |                       |      |   |
| \<p v‐for="item in dataArr"\>值：{{item}} |       |                       |      |   |

    1.  \<p v‐for="(item,i) in dataArr"\>索引：{{ 上索引遍历 ‐‐\>

        \</

        p\> }

        \<!‐‐

        不加索引遍历

        >   值：{{item}

        ‐‐\>

        \<!‐‐ p\> 加

|   | i} |   | ====== |   | \</ } |   |   |   |
|---|----|---|--------|---|-------|---|---|---|


2.  使用v-for指令遍历字符串数组

| 1 |
|---|


    >   2

    \<!‐‐

    使用v‐for遍历字符串数组 ‐for="(item,i) in strArr" ‐‐\>

    ‐‐\>

    ======

    值：{{item}}

    \</

    p\>

    \<!‐‐

    索引：{{i}} 加

|   | \<p v 上索引遍历 |   | \> |   |   |   |   |   |   |   |
|---|------------------|---|----|---|---|---|---|---|---|---|


3.  使用v-for指令遍历对象数组

| 1 |
|---|


    >   2

    >   te

    \<!‐‐

    使用v‐for遍历对象数组 ‐for="(item,i) in objArr" me}} ==== AGE:{{item.

    ‐‐\>

    \>索引：{{i}}

    >   }\</p\>

    ===

    ID：{{item.id}}

    === NAME:{{

|                          | \<p v m.na |                                           | age} |                |     |                    |   |   |   |   |
|--------------------------|------------|-------------------------------------------|------|----------------|-----|--------------------|---|---|---|---|
| 4、使用v-for指令遍历对象 |            |                                           |      |                |     |                    |   |   |   |   |
| 1                        | \<!‐‐      | 使用v‐for遍历对象 ‐for="(val,key) in obj" | ‐‐\> | \>key：{{key}} | === | \</ 值：{{val}}p\> |   |   |   |   |
|                          | \<p v      |                                           |      |                |     |                    |   |   |   |   |

>   2

>   i

1.  使用v-for迭代数字

| 1 |
|---|


    >   2

    \<!‐‐

    使用v‐for迭代数字 ‐for="count in totle"

    ‐‐\>

    \</

    >   \>这是第{{count}}次循环 p\>

|   | \<p v |   |   |   |   |   |
|---|-------|---|---|---|---|---|


2.  在2.2.0+版本后，当在组件中使用v-for指令时，key是必须的

| \<script src="./lib/vue.js" |
|-----------------------------|


    1.  \<body\>

        1.  \<div id="app"\>

            1.  \<p v‐for=

            2.  \<input type=

            >   {{val}}

| \</ |
|-----|


    2.  p\>

| \</ |
|-----|


    3.  div\>

        1.  \<script\>

            1.  var vm = new Vue({

            2.  el:"\#app",

            3.  data:{ 12 obj:{

            4.  "id":

            5.  "name"

            6.  "age"

            7.  }

            8.  },

        \>\</

        script\>

        >   :key="key"\>

        "checkbox"\>索引：{{i}} ===key：{{key}} === val：

        "秦始皇",

|                | "(val , key, i) in obj" 1, |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|----------------|----------------------------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| 18 methods:{ } |                            |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |

>   :

: 86

十二、v-if和v-show指令的使用
============================

v-if 特点：每次都会进行DOM元素的删除和创建操作，重新删除或者创建元素。

| \</ 19 }); 20 script\> |
|------------------------|


v-show
特点：每次不会进行DOM元素的删除和创建操作，只是切换元素的display:none样式。

v-if：有较高的切换性能消耗

>   v-show：有较高的初始渲染消耗

![](media/80aede355a3f991103cdc80b6c7e0817.png)

| el: "\#app", |
|--------------|
| \</          |
| \</          |

1.  data: {

2.  flag: false

3.  },

4.  methods: {

5.  toggle(){

6.  this.flag = !this.flag;

7.  }

8.  } 33 });

34 script\>

35body\>

十三、VUE中过滤器filter的定义和使用
===================================

1.  Vue中全局过滤器的定义语法：

| 全局过滤器：Vue.filter('filterName',function(arg){}) |
|------------------------------------------------------|


    1.  filterName: 是过滤器的名称，第二个参数是回调函数

        1.  注意：过滤器中的回调方法funciton的第一个参数已经被限制死了，

            1.  永远都是过滤器管道符（\|） 前面的那个数据

         

         

         

         

         

| \<script src="./lib/vue.js" |       |                                                                                                                         |   |   |   |   |   |   |
|-----------------------------|-------|-------------------------------------------------------------------------------------------------------------------------|---|---|---|---|---|---|
| \<!‐‐                       |       |                                                                                                                         |   |   |   |   |   |   |
| ‐‐\>                        |       |                                                                                                                         |   |   |   |   |   |   |
| \<!‐‐                       |       |                                                                                                                         |   |   |   |   |   |   |
| ‐‐\>                        |       |                                                                                                                         |   |   |   |   |   |   |
| \</                         | \>\</ | script\> filter('filterName',function(arg){}) 是过滤器的名称，第二个参数是回调函数 funciton的第一个参数已经被限制死了， |   |   |   |   |   |   |
| \</                         |       |                                                                                                                         |   |   |   |   |   |   |
|                             | .     |                                                                                                                         |   |   |   |   |   |   |
| 21                          |       |                                                                                                                         |   |   |   |   |   |   |
| \<script\>                  |       |                                                                                                                         |   |   |   |   |   |   |
| \</                         |       |                                                                                                                         |   |   |   |   |   |   |
| \</                         |       |                                                                                                                         |   |   |   |   |   |   |

2.  \<body\>

3

1.  Vue中过滤器的定义语法：

2.  全局过滤器：Vue

3.  filterName:

4.  注意：过滤器中的回调方法

5.  永远都是过滤器管道符（

6.  例如：

7.  Vue.filter(

8.  return data

9.  });

>   13

1.  \<div id="app"\>

2.  过滤器的调用：数据

3.  注意：(1)

4.  (2)

>   18

1.  \<p\>{{ msg \| msgFormat

2.  div\>

>   \|） 前面的那个数据

'testFilter',function(data){

"123";

>   \| 过滤器名称

、这儿过滤器也是可以传参的，并且可以传多个参数

、过滤器可以多个同时调用，只需要用管道符 \| 拼接起来即可。

>   ('邪恶','123') \| msgFormat2 }} p\>

>   \+

1.  //定义一个Vue全局过滤器msgFormat

2.  Vue.filter('msgFormat', function (msg, arg, arg2) {

3.  //吧msg中 单纯 变为 邪恶

26

1.  /\* 字符串的replace方法第一个参数可以写字符串之外，还可以写正则 \*/

2.  //return msg.replace('单纯','邪恶'); 29 return msg.replace(/单纯/g, '邪恶');

30 });

31

1.  Vue.filter('msgFormat2', function (msg) {

2.  return msg + "======";

3.  });

4.  var vm = new Vue({

5.  el: "\#app",

6.  data: {

7.  msg: "曾经我也是个单纯的男人，单纯的我对着镜子问，谁是这个世界上
    单纯的男人！"

8.  },

9.  methods: {

10. } 42 });

43 script\>

44body\>

1.  私有过滤器的定义注意： （1）、全局过滤器是在全局的js中去定义的。且需要使用

>   Vue.filter()方式来定义。

私有过滤器是在Vue实例中通过属性filters定义得。

1.  、过滤器两个要素：名称和回调函数

2.  、过滤器在调用的时候采用的是就近原则。如果私有过滤器

和全局过滤器名称相同，则优先调用私有过滤器。

| },  |
|-----|
| \*/ |

1.  methods: { },

2.  //定义私有过滤器 在Vue实例中

3.  /\* 过滤器调用的时候，采用的是就近原则。如果私有过滤器和全局过滤器名称一致，

4.  优先调用私有过滤器

10

1.  filters: { //过滤器两个条件：过滤器名称 和 处理函数

2.  dataFormat(dataStr,pattern=""){

3.  //根据给定的时间字符串来创建一个时间对象

4.  var dt = new Date(date);

5.  var y = dt.getFullYear().toString().;

6.  var m = dt.getMonth() + 1;

7.  var d = dt.getDate();

18

1.  //return y + "‐" + m + "‐" + d;

2.  /\* 使用模板字符串 \*/

3.  if (pattern && pattern.toLowerCase() == 'yyyy‐mm‐dd') {

4.  return \`\${y}‐\${m}‐\${d}\`;

5.  } else { //返回加时分秒的时间格式

6.  var h = dt.getHours();

7.  var mi = dt.getMinutes();

8.  var s = dt.getSeconds();

9.  return \`\${y}‐\${m}‐\${d} \${h}:\${mi}:\${s}\`;

10. }

11. }

12. }

13. });

14. 过滤器调用语法：

| 1 |
|---|


    >   2

    >   3

    >   4

    >   5

    \<!‐‐

    过滤器的调用：数据 \|
    过滤器名称注意：(1)、这儿过滤器也是可以传参的，并且可以传多个参数
    (2)、过滤器可以多个同时调用，只需要用管道符 \| 拼接起来即可。

| \</ |
|-----|


    {{ msg \| msgFormat('邪恶','123') \| msgFormat2 }} p\>

|   | ‐‐\> \<p\> |   |   |   |   |   |   |   |
|---|------------|---|---|---|---|---|---|---|


十四、品牌列表实例
==================

2 \<meta charset="UTF‐8"\>

| 5                           |                                         |          |   |   |   |   |   |   |
|-----------------------------|-----------------------------------------|----------|---|---|---|---|---|---|
| \<script src="./lib/vue.js" |                                         |          |   |   |   |   |   |   |
| \<!‐‐                       |                                         |          |   |   |   |   |   |   |
| ‐‐                          |                                         |          |   |   |   |   |   |   |
| \</                         |                                         |          |   |   |   |   |   |   |
| \</                         | \>\</                                   | script\> |   |   |   |   |   |   |
| /\>                         |                                         |          |   |   |   |   |   |   |
| \</                         |                                         |          |   |   |   |   |   |   |
|                             | = "panel panel‐primary" "panel‐heading" |          |   |   |   |   |   |   |
|                             |                                         |          |   |   |   |   |   |   |

1.  \<link rel="stylesheet" href

2.  注意：在这里其实没必要引入

3.  而Vue恰恰是不提倡操作DOM

4.  \> 11head\>

5.  \<body\>

6.  \<div id="app"\>

>   14

1.  \<div class=

2.  \<div class=

3.  \<h3 calss=

4.  \</div\>

5.  \<div class= 20 \<label\>

6.  序号：

7.  \<input type trol" v‐model="id" /\>

8.  \</label\>

9.  \<label\>

10. 名称：

11. \<input type

>   ‐control" v‐model="name" /\> 27 \</label\>

>   28

>   29 \<input type= primary" \@click.prevent="add" /\>

>   30

1.  \<label\>

2.  根据关键词过滤：

3.  \<input type

>   ‐control" v‐model="keywords" /\>

1.  \</label\>

2.  \</div\>

3.  div\>

4.  \<table class=

5.  \<thead\>

6.  \<tr\>

7.  \<th\>

8.  序号

"./lib/bootstrap.css"

Jquery类库，因为Jquery是操作DOM元素的。元素。但是非要引入也是可以的。

>   \>

>   \>

"panel‐title"\>添加品牌h3\>

"panel‐body form‐inline"\>

"text" name="id" id="id" class="form‐con

"text" name="name" id="name" class="form

>   value="添加" class="btn btn‐

"text" name="filter" id="filter" class=

"table table‐bordered table‐hover"\>

>   =

>   =

"button"

>   =

>   "f

![](media/55e35aa575436fa5b739e008a9a389c1.png)

![](media/56e884efba9e19d5827f542a4434445e.png)

![](media/a7ec18f785d1d7787302e78dd66ededb.png)

| return newList; |
|-----------------|
| \*/             |
| \</             |
| \</             |

1.  }

2.  /\* 注意：数组的方法
    forEach、some、filter、findIndex、这些都属于数组的新方法。

3.  都会对数组的每一项进行遍历，执行相关的操作。

159

160 } 161 });

162script\>

163html\>

十五、Vue为Dom元素绑定键盘事件
==============================

使用事件绑定指令v-on为也可为元素绑定键盘事件。

| 1 |
|---|


>   2

>   3

>   4

>   5

>   6

>   7

>   8

\<!‐‐

为input元素绑定键盘事件 当按键为enter键时，调用add方法。 keyup：键盘释放时调用
keydown：键盘按下时调用 enter键盘事件修饰符：具体判断当操作哪个键时调用

| /\> |
|-----|


input type="text" v‐on:key‐up.enter="add"

| ‐‐\> |
|------|


v‐on缩写为：\@

| /\> |
|-----|


input type="text" \@key‐up.enter="add"

|       | . |   |   |   |   |   |   |   |   |   |   |   |
|-------|---|---|---|---|---|---|---|---|---|---|---|---|
| ‐‐\>  |   |   |   |   |   |   |   |   |   |   |   |   |
| \<!‐‐ |   |   |   |   |   |   |   |   |   |   |   |   |

\<

\<

1.  Vue提供的键盘事件修饰符：

    1.  .enter ：捕获“回车键”

    2.  .tab ：捕获“Tab键”

    3.  .delete ：捕获“删除”和“退格键”

    4.  .esc ：捕获“Esc键”

    5.  .space ：捕获“空格键”

    6.  .up ：捕获“方向‐上键”

    7.  .down ：捕获“方向‐下键”

    8.  .left ：捕获“方向‐左键” 9 .right ：捕获“方向‐右键”

2.  Vue中自定义全局按键修饰符

    1.  /\* 自定义全局案件修饰符 \*/

    2.  Vue.config.keyCodes.f2=113

十六、自定义指令
================

1.  定义全局指令

>   注意：在Vue中，所有的指令，在调用的时候，都是 v- 开头 指令定义：

| //定义全局的自定义指令 |
|------------------------|
| \*/                    |
| \*/                    |
| \*/                    |

1.  /\*

2.  使用Vue.directive(arg1,arg2)来自定义全局的指令

3.  参数1：指令的名称。 注意：在定义的时候，指令的名称前面不需要加 v‐ 前缀，

4.  但是在调用的时候必须在指令的前面加上 v‐ 前缀

5.  参数2：是一个对象，这个对象上有一些与指令相关的函数，这些函数可以在特定的阶段执行相关的操作

6.  注意：在每个函数中，第一个参数永远是el，这个el标识绑定指令的那个元素，

7.  这个el是一个原生的js对象

9

1.  Vue.directive('focus',{

2.  //每当指令绑定到元素的身上的时候，会立即执行这个 bind函数，只执行一次

3.  /\* bind: function(el){

4.  },

5.  //每当元素被插入到Dom的时候，会执行这个 inserted 函数，之触发一次

6.  inserted: function (el){

7.  el.focus();

8.  },

9.  //当元素更新的时候会执行updated，且可能会执行多次

10. /\* updated: function(el){

11. }

12. });

>   指令调用：

| \<label\> |
|-----------|
| /\>       |
| \</       |

1.  根据关键词过滤：

2.  \<input type="text" class="form‐control" v‐model="keywords" v‐focus

4label\>

1.  //el.style.color = "red";

2.  console.log(binding.name);//指令名称

3.  console.log(binding.value);//传入的指令的值

4.  console.log(binding.expression);//传入指令的表达式

5.  el.style.color = binding.value;

6.  }, 15 })

7.  自定义私有指令

私有指令定义在Vue实例中，通过directives{}来定义。基本的定义语法和全局指令一

样。

| //定义一个Vue实例，用来控制appDOM元素 |
|---------------------------------------|
| \*/                                   |

1.  var vm = new Vue({

2.  el: "\#app",

3.  data: {

4.  },

5.  methods: {

6.  },

7.  /\* 定义私有指令

8.  字体加粗

10

1.  directives: {

2.  'fontweight': {

3.  bind: function (el, binding) { 14 console.log(binding.value)

4.  el.style.fontWeight = binding.value;

5.  }

6.  }

7.  }

8.  });

9.  自定义指令简写

| /\* 自定义指令简写：如果只是使用bind和updated两个钩子函数的时候， |
|-------------------------------------------------------------------|
| \*/                                                               |

10. 就可简写为如下形式

3

1.  'fontsize': function(el,binding){

2.  el.style.fontSize=parseInt(binding.value)+"px";

3.  }

注意：自定义指令的时候，指令的名称只能用小写，不能大写，而且不能出现-等符号

十七、Vue实例的生命周期
=======================

1.  生命周期介绍

什么是生命周期？从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，就统称为生命周期。

>   生命周期钩子 = 生命周期函数 = 生命周期事件

1.  主要的生命周期函数分类

    1.  、创建期间的生命周期函数

>   beforeCreate()、created（）、beforeMount（）、mounted

1.  、运行期间的生命周期函数

>   beforUpdate（）、updated

1.  、销毁期间的生命周期函数beforeDestory、destoryed

| \<script src="./lib/vue.js" |
|-----------------------------|


    1.  \<body\>

        1.  \<div id="app"\>

            1.  \<h3 id = "h3"\>{{

| \</ |
|-----|


    2.  div\>

        1.  \<script\>

            1.  var vm = new Vue({

            2.  el: "\#app",

            3.  data: {

            4.  msg: "Hello!"

            5.  }

            6.  ,methods: { 13 show(){

            7.  console

            8.  }

            9.  },

            10. /\*

            11. 注意：在

            12. data中的数据和

| \*/ |
|-----|


    >   20

    >   21 beforeCreate(

    >   22

    1.  },

        1.  /\*

            1.  注意：在

        \>\</

        script\>

| \</ |
|-----|


    >   }} h3\>

    log("调用了show方法！");

    >   Vue实例被完全创建之前，会执行他生命周期函数被调用时时，
    >   methods中的方法都还没有呗初始化，还无法调用

    >   Vue实例被完全创建后，会执行他方法被调用的时候，Vue实例已经完全创建，

|   | msg |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|---|-----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|   |     |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |

>   .

这是第一个生命周期函数，

beforeCreate

){

这是第二个生命周期函数，在

created

| 26 data中的数据和methods中的方法也都被创建，可以开始调用了 |
|------------------------------------------------------------|
| \*/                                                        |

>   27

1.  created(){

    1.  console.log(this.msg);

        1.  this.show();

            1.  },

            2.  /\*

            3.  这是第三个生命周期函数，模板（html界面）已经在内存里便已完成，在挂载到界面上之前调用它

            4.  注意：再beforeMount方法里，就可以开始使用DOM元素了。

            5.  但页面中的元素都还没赋值，只是一些占位符

| \*/ |
|-----|


    >   36

    1.  beforeMount(){

        1.  console.log(Document.getElementById("h3").innerHtml());
            结果：{{msg}}

            1.  },

            2.  /\*
                这是第四个生命周期函数，标识内存中的模板已经真实的挂载到了页面中，用户已经看到界面了

            3.  mount是实例创建期间 后一个生命周期函数。

            4.  mount方法被执行的时候Vue实例就已经彻底被创建成功了。

            5.  组件已经脱离创建阶段，进入到了运行阶段。

| \*/ |
|-----|


    >   44

    1.  mounted(){

        1.  console.log(Document.getElementById("h3").innerHtml()); 结果："ok"

            1.  },

            2.  /\*

            3.  运行阶段的两个生命周期函数会根据data数据的改变有选择性的触发，
                50 少触发0次（数据从未改变）， 多触发无数次。

            >   51

            1.  运行阶段第一个生命周期函数

            2.  beforUpdate被触发时，界面还没被更新，但是数据已经被更新了，

            3.  此时界面上显示的数据还是旧数据，data中的数据是
                新的发，页面上的数据还未同步

| \*/ |
|-----|


    >   55

    >   56 beforUpdate(){

    >   57

    1.  },

        1.  /\* 运行阶段第二个生命周期函数

            1.  updated时间被执行的时候，页面上的数据和data中的数据已经保持同步了，都是
                新的

| 61 | \*/ |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|----|-----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


>   //

>   //

| updated(){ |
|------------|


1.  //数据更新后

    >   64

    1.  },

        1.  /\*

            1.  销毁阶段两个生命周期函数

            2.  beforeDestory和destoryed

            >   69

            1.  当执行beforeDestory时，Vue实例就已经从运行阶段进行到了销毁阶段。

            2.  此时Vue实例中所有的data、methods、filters、directives等都还未被销毁，

            3.  都是可用状态

| \*/ |
|-----|


    >   73

    1.  beforeDestory(){

        1.  //销毁前

            1.  },

            2.  /\* 当执行到destoryed时，实例已经完全被销毁了

            3.  此时Vue实例中所有的data、methods、filters、directives等都还已经被销毁，

            4.  都不可用了

| \*/ |
|-----|


    >   80

    1.  destoryed(){

        1.  //销毁完毕

            1.  }

            >   84

            1.  })

| \</ |
|-----|


    2.  script\>

| 87 | \</ | body\> |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|----|-----|--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


十八、使用Vue-resource中的ajax请求

（get、post请求）改善品牌列表，从后台数据库中获取数据

>   1 \<head\>

![](media/fe37e651d905e4b5c3d337d66edf9525.png)

![](media/dc64a879086c83ecbe24e6680b47f401.png)

1.  this.\$http.post()接受三个参数

2.  第一个参数：要请求的url地址

3.  第二个参数：要提交给服务器的数据，以对象形式进行提交

>   {name : this.name}

1.  第三个参数：是一个配置对象，要以哪种表单数据类型进行提交，{emulateJSON：true}，

2.  以普通标单格式将数据提交给服务器： application/x‐www‐form‐urlencoded

3.  \*/

4.  this.\$http.post('http://vue.studyit.io/api/addlist/',

5.  name: this.name

6.  }, {

7.  emulate: true

8.  }).then(result =\> {

9.  if (result.body.status == 0) {

92 //添加成功，获取 新数据刷新列表
----------------------------------

1.  this.getAllList()

2.  } else {

3.  alert("添加失败！")

4.  }

5.  });

6.  },

7.  del(id) {

8.  //使用ajax请求删除指定的item

9.  this.\$http.get('http://vue.studyit.io/api/dellist/' d).then(result =\> {

10. if (result.body.status === 0) {

103 //删除成功，刷新列表 
-------------------------

1.  this.getAllList();

2.  } else {

3.  alert("删除失败！")

4.  }

5.  })

6.  },

7.  getAllList() {

111 //在这个方法中使用vue‐resources中的ajax请求 访问后台数据库， 112 //拿到数据
-------------------------------------------------------------------------------

1.  this.\$http.get('http://vue.studyit.io/api/getprodlis t').then(result =\> {

2.  var result = result.body; //通过\$http获取的数据 都在result.body中放着

| if (result.status === 0) { |
|----------------------------|


    1.  this.list = result.message

        1.  } else {

            1.  alert("数据调取失败！")

            2.  }

            3.  });

            4.  }

            5.  },

            6.  filters: {}

            7.  });

| \</ |
|-----|


    2.  script\>

| 126 | \</ | body\> |   |   |   |   |   |   |   |   |   |
|-----|-----|--------|---|---|---|---|---|---|---|---|---|


十九、添加全局配置
==================

1、使用全局配置，配置请求地址的根路径（域名）

>   Vue.http.options.root = '';

| //使用全局配置，配置请求的根路径 |
|----------------------------------|
| \*/                              |

1.  /\*

2.  注意：如果使用了全局配置，配置了请求的根路径。那么在每次使用http请求时，

3.  请求的url路径，必须以相对路径开头，前面不能加 /,否则不会启用根路径拼接

5

6 Vue.http.options.root = 'http://vue.studyit.io/';

使用的时候：

1 //此处url启用了全局配置，所以必须使用相对路径，前面不能加 /
-------------------------------------------------------------

### 2 this.\$http.post('api/addlist/', {

1.  name: this.name

2.  }, {

3.  emulate: true

4.  }).then(result =\> {

5.  if (result.body.status == 0) {

8 //添加成功，获取 新数据刷新列表
---------------------------------

1.  this.getAllList()

2.  } else {

3.  alert("添加失败！")

### 12 } 13 });

2、全局配置，启用标单提交时的emulationJSON=true

>   Vue.http.options.emulateJSON = true;

| //发送post请求添加数据 |
|------------------------|
| \*/                    |

1.  /\*

2.  this.\$http.post()接受三个参数

3.  第一个参数：要请求的url地址

4.  第二个参数：要提交给服务器的数据，以对象形式进行提交{name : this.name

5.  第三个参数：是一个配置对象，要以哪种表单数据类型进行提交，{emulateJSO

>   N：true}，

1.  以普通标单格式将数据提交给服务器：application/x‐www‐form‐urlenco ded

2.  注意：如果全局启用了emulateJSON=true，咱第三个参数可省略

10

1.  //此处url启用了全局配置，所以必须使用相对路径，前面不能加 /

2.  this.\$http.post('api/addlist/', {

3.  name: this.name 14 }).then(result =\> {

4.  if (result.body.status == 0) {

5.  //添加成功，获取 新数据刷新列表

6.  this.getAllList()

7.  } else {

8.  alert("添加失败！")

9.  }

10. });

11. }

}

二十、Vue中组件的使用
=====================

1.  组件的概念

组件的出现就是为了拆分Vue实例的代码量的，能够让我们以不同的组件来划分不同的功能模块，将来我们需要什么的样的功能，就可以去调用对应的组件即可。

1.  组件化和模块化的不同

模块化是从代码逻辑的角度进行划分；方便后代的分层开发，保证每个功能模块的职能单一。

>   组件化是从UI界面的角度去进行划分的；方便前端UI组件的重用。

1.  Vue中定义全局组件（公三种方式，推荐使用第三种）第一种：三步骤

    1.  、使用Vue.extend({ template : " " })定义组件模板，会返回一个模板实例对象

    2.  、使用Vue.component("组件名称"，模板实例对象)来注册组件

    3.  、在被控制的元素里面使用组件

| 1 \<div id="app"\> |                                                                    |      |
|--------------------|--------------------------------------------------------------------|------|
| \<!‐‐              | 在使用组件的时候，直接组件的名称已HTML标签的刑事，引入到页面中接口 | ‐‐\> |
| \>\</              |                                                                    |      |
| \</                |                                                                    |      |
| \</                |                                                                    |      |

2

3 \<mycom1 mycom1\>

4div\>

1.  \<script\>

2.  //1.1、Vue创建组件的第一种方式 使用Vue.extend来创建全局的组件

3.  var com1 = Vue.extend({ //返回一个模板名称

4.  //通过template属性 指定组件要展示的html结构

5.  template: '\<h3\>这是使用Vue.extend 创建的组件\</h3\>'

6.  });

7.  //1.2、使用Vue.component('组件名称',创建出来的组件模板对象) 来注册组件

8.  //如果使用Vue.component注册全局组件的时候，组件名称使用了驼峰格式命名，需要把打字的字母改成小写的字母，同时两个字母之间使用‐链接

9.  //如果组件名称不适用驼峰格式命名，则使用的时候直接引用即可。

10. Vue.component('mycom1', com1)

15

1.  //缩写

2.  Vue.component('mycom2', Vue.extend({ //返回一个模板名称

3.  //通过template属性 指定组件要展示的html结构

4.  template: '\<h3\>这是使用Vue.extend 创建的组件2\</h3\>'

5.  }))

21

1.  var vm = new Vue({

2.  el: "\#app",

3.  data: {},

4.  methods: {}

5.  });

27script\>

第二种： 直接使用Vue.component()来进行定义

| //注意：无论是那种方式组件组件，组件的template指向的模板内容，必须有且只有一个根元素 |
|--------------------------------------------------------------------------------------|
| \</                                                                                  |

1.  Vue.component('mycom2', {

2.  template: '\<h3\>这是使用Vue.component直接创建出来的组件\</h3\>' 9 })

10

1.  var vm = new Vue({

2.  el: "\#app",

3.  data: {},

4.  methods: {}

5.  })

16script\>

第三种：使用ID引入模板的方式进行定义

| \<div id="app"\> |                                                       |      |
|------------------|-------------------------------------------------------|------|
| \>\</            |                                                       |      |
| \</              |                                                       |      |
| \<!‐‐            | 在被控制的app外面，使用template元素，定义组件的模板结 | ‐‐\> |
| \</              |                                                       |      |
| \</              |                                                       |      |
| \</              |                                                       |      |
| \</              |                                                       |      |
| \</              |                                                       |      |

1.  \<mycom3 mycom3\>

3div\>

4

5

1.  \<template id="temp3"\>

2.  \<div\>

3.  \<h1\>这是通过template在外部定义的组件的结构，这个方式有代码的提示和高亮
    h1\>

4.  \<h4\>好用，有提示！ h4\>

5.  div\>

11template\>

12

1.  \<script\>

2.  //2,Vue创建全局组件的第二种方式 直接适用Vue.component()创建

3.  //注意：无论是那种方式组件组件，组件的template指向的模板内容，必须有且只有一个根元素

4.  Vue.component('mycom3', {

5.  template: '\#temp3'

6.  })

19

1.  var vm = new Vue({

2.  el: "\#app",

3.  data: {},

4.  methods: {}

5.  })

25script\>

1.  Vue中使用components定义私有组件

| \<body\> |
|----------|
| \>\</    |
| \>\</    |
| \</      |
| \</      |
| \</      |
| \</      |
| \</      |
| \</      |

2.  \<div id="app"\>

3.  \<login login\>

4.  \<login2 login2\>

5.  div\>

6.  \<template id="selftmp"\>

7.  \<div\>

8.  \<h3\>这是使用ID关联创建的一个私有组件 h3\>

9.  div\>

10. template\>

11. \<script\>

12. var vm = new Vue({

13. el: "\#app",

14. data: {},

15. methods: {},

16. components: {

17. login: {

18. template: '\<h3\>这是使用components创建的一个私有组件\</h

>   \>'

1.  },

2.  login2: { //使用ID外部关联template内容

3.  template: '\#selftmp'

4.  }

5.  } 24 })

25 script\>

26body\>

3

1.  私有组建中的data和methods

>   注意：私有组建中data和Vue实例中的data不一样。

私有组建中的data必须是个方法，切该方法必须返回一个内部的对象，该对象就不能定义到外部去

>   1 \<body\>

![](media/f2769b77623fb9da9cf9c9f6714fe10a.png)

| 43  |
|-----|
| \</ |
| \</ |

1.  filters: {}, //定义过滤器

2.  directives: {}, //定义自定义指令

3.  components: {}, //定义私有组件

47

1.  beforeCreate() {},

2.  created() {},

3.  beforeMount() {},

4.  mounted() {},

5.  beforeUpdate() {},

6.  updated() {},

7.  beforeDestroy() {},

8.  destroyed() {},

9.  })

10. script\>

58body\>

1.  组件切换

| data: { |
|---------|
| \</     |
| \</     |

2.  comName: 'logincom'

3.  },

4.  methods: {},

28

1.  filters: {}, //定义过滤器

2.  directives: {}, //定义自定义指令

3.  components: {}, //定义私有组件

4.  })

5.  script\>

34body\>

1.  父子组件之间传值

    1.  、父组件中调用子组件时，可通过属性绑定v-bind定义一个自定义变量，将父组件中data中的数据传递到子组建中使用

| \<div id="app"\> |
|------------------|
| \<!‐‐            |
| ‐‐\>             |
| \>\</            |
| \</              |

2.  父组件中调用子组件时 可通过v‐bind属性绑定的方式，定义一个自定义属性，

3.  将父组件中data中的数据传递到子组件中使用

4

5 \<com1 v‐bind:parentmsg="msg" com1\>

6div\>

1.  、在子组件的props中定义父组件传递过来的数据，这一步是必须的

2.  、在父组件中调用

注意：子组件中data和props的区别：

1.  、子组件中data是一个方法，并且返回一个内部对象；data中的数据不是父组件中传递过来的，是子组件自身私有的数据，比如子组件通过ajax请求到的数据；data中的数据是可读可写的。

2.  、子组件中的props是一个数组，所有通过父组件中传递过来的数据，都必须先在props中定义后才可在子组件中使用。props中的数据因为是从父组件中传递过来的，所以是只读的，不能改写

![](media/366dbc5235b02afbeb1df0c5e065bb91.png)

8、子组件调用父组件方法
=======================

| // props中的数据因为是从父组件中传递的，所以都是只读的，不可被修改 |
|--------------------------------------------------------------------|
| \</                                                                |
| \</                                                                |
| \</                                                                |

1.  props: ['parentmsg'],

2.  template: '\<h1\>这是一个子组件‐‐‐‐‐ {{parentmsg}} \</h1 \>',

3.  }

4.  } 50 });

51 script\>

52body\>

53html\>

1.  、父组件中调用子组件时，可通过时间绑定机制v-on定义一个自定义变量，将父组件中methods中的方法传递到子组建中使用

| \<div id="app"\> |
|------------------|
| \<!‐‐            |
| ‐‐\>             |
| \>\</            |
| \</              |

2.  父组件传递方法到子组件时

3.  使用事件绑定机制 v‐on \@ 绑定一个自定义事件属性，子组件就可以调用了

4

5 \<com1 v‐on:funct="show" com1\>

6div\>

1.  、然后就可在子组件中通过自定义的方法变量调用父组件中的方法了

| var com1 = { |
|--------------|
| \</          |
| \</          |

2.  template: '\#com1',

3.  methods: {

4.  myclick() {

5.  //在子组件中通过this.\$emit('')来调用父组建中的方法

6.  this.\$emit('funct', 123, 456)

7.  }

8.  }

9.  }

10. var vm = new Vue({

11. el: '\#app',

12. data: {},

13. methods: {

14. show(data, data2) {

15. console.log("调用了父组件身上的show‐‐‐‐‐" + data + dat a2)

16. }

17. },

18. components: {

19. com1 //com1：com1

20. } 36 })

37 script\>

38body\>

9、父子组件数据和方法调用-品牌案例
==================================

| \<body\> |                              |      |
|----------|------------------------------|------|
| \<!‐‐    | 父组件传递自己的方法给子组件 | ‐‐\> |
| \>\</    |                              |      |
| \</      |                              |      |
| \</      |                              |      |
| \</      |                              |      |
| \</      |                              |      |
| \<!‐‐    | 添加发布评论的组件           | ‐‐\> |

1.  \<div id="app"\>

3

1.  \<commentteml v‐on:func='getComments' commentteml\>

2.  \<ul class="list‐group"\>

3.  \<li class="list‐group‐item" v‐for="

>   (item,i) in contents" :key="item.id"\>

1.  \<span class="badge"\>评论人：{{item.user}} span\> {{item.co ntent}}

2.  li\>

3.  ul\>

4.  div\>

11

1.  \<template id="commentteml"\>

2.  \<div\>

![](media/5d1689a7af8555cc897905b07fa226f3.png)

![](media/4dfa93d2526fa7b310a15b1d33b989e0.png)

| }   |
|-----|
| \</ |
| \</ |

1.  },

2.  components: {

3.  commentteml, //挂载组件

4.  } 93 })

94 script\>

95body\>

二十一、Vue中使用ref属性获取dom元素
===================================

1.  通过给元素添加ref属性，可以获该元素的原生DOM对象，从而获取钙元素的一些属性值。

2.  通过给组件添加ref属性，可以获取和调用该组件data中的数据以及methods中的方法。

| }, |
|----|


    1.  template: "\<h3\>这是login组件\</h3\>"

        1.  });

            1.  var vm = new Vue({

            2.  el: "\#app",

            3.  data: {},

            4.  methods: {

            5.  getelement() { //使用ref属性获取dom节点

            6.  var butHtml = this.\$refs.myBut.innerText;

            7.  var spanHtml = this.\$refs.myspan.innerText;

            8.  console.log(spanHtml + "‐‐‐‐‐" + butHtml);

            9.  //通过ref可以获取组建中的data和方法

            10. var msg = this.\$refs.loginCom.msg;

            11. console.log(msg);

            12. this.\$refs.loginCom.show();

            13. }

            14. } 43 })

| \</ |
|-----|


    >   44 script\>

| 45 | \</ | body\> |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|----|-----|--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


二十二、Vue中的路由（Route）
============================

1.  什么是路由

    1.  ：后端路由

>   对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源；

1.  ：前端路由

>   对于单页面应用程序来说，主要通过URL中的hash(\#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现；

1.  、在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）；

2.  在Vue中使用vue­route 导入组件类库

| 1 \<script src="./lib/vue‐router‐2.7.0.js" | \>\</ | script\> |
|--------------------------------------------|-------|----------|
|                                            |       |          |

3.  路由的简单使用

    1.  安装vue-router路由模块

    2.  创建VueRouter对象，并且配置相应的路由匹配规则，不通的url地址匹配不通的组件模板对象。注意：new
        VueRouter({})要在new Vue({})之前

    3.  通过router属性将路由对象注册到实例中去

    4.  通过vuerouter提供的\<router-view\>\</router-view\>标签，展示路由模块

    5.  通过\<transition
        mode="out-in"\>标签包括\<router-view\>可以为路由组件切换时指定动画

    6.  可使用vuerouter提供的\<router-link\>标签替换超链\<a\>标签。

\<router-link\>标签默认底层会渲染成\<a\>标签，也可通过其上的tag属性指定要渲染成指定的标签，例如：tag="span"

>   \<router-link\>标签上的to属性，为路由指向的组件url地址

![](media/fcc59cb469d920ec602a3bc9e6bd1dee.png)

![](media/f5f70f6c42d5ccb314290a8a53447c14.png)

| var routeObj = new VueRouter({ |
|--------------------------------|
| \</                            |
| \</                            |

1.  routes: [ //这里的route指的是【路由匹配规则】的意思，可以有很多个

2.  //每个路由匹配规则都是一个对象，这个对象上有两个必须的属性

3.  //属性1：path 表示监听哪个路由链接地址

4.  //属性2：component 标识前面path匹配到的路由链接地址 展示哪个对应的组件

5.  //component的属性值必须是一个组件模板对象，不能是组件的注册名称

6.  {

7.  path: '/login',

8.  component: login

9.  }, {

10. path: '/register',

11. component: register

12. }

13. ],

14. //可以通过linkActiveClass属性指定路由高亮显示的样式

15. //如果不指定，默认样式名称为.router‐link‐active

16. linkActiveClass: 'myrouteactiveclass'

17. })

18. var vm = new Vue({

19. el: "\#app",

20. data: {

86

1.  },

2.  methods: {

89

1.  },

2.  router: routeObj //将路由对象注册到Vue实例上，检测url地址的变化

3.  })

4.  script\>

94body\>

1.  路由（VueRouter）中的参数传递

    1.  路由（VueRouter）传值第一种方式

在\<router-link\>元素的属性to="/login?id=10&name=lisi"直接通

过?拼接参数即可

然后在组件模板中直接使用 插值表达式{{}} 通过 \$route.query.参数名 取值即可

1.  路由纯质第二种方式

先在VueRouter对象里的路由匹配规则routes中每一个路由匹配对象的path属性上，使用占位符
/:参数名/:参数2 ，再在\<router-link\>元素的属性to上直接拼接参数值即可
to="register/10/zhangsan"

然后在路由对应的组建中就可以使用 插值表达式{{}} 通过 \$route.params.参数名 取值

1.  综合比较

第一种方式直接在\<router-link\>元素饿的to属性使用 ?参数名=参数值
进行参数拼接即可。通过 \$router.query.属性名取值。

第二种方式需要在路由匹配对象的path提前通过 :属性名
定义占位符，然后在\<router-link\>元素的to属性上直接拼接参数值即可，不用再拼接属性名。通过
\$router.params.属性名取值。

![](media/fc149ec8aa91c994568ee77431a52ac0.png)

1.  路由（VueRouter）嵌套

| data: {}, |
|-----------|
| \</       |
| \</       |

2.  methods: {},

3.  router: routerObj //将路由 对象注册到Vue实例上去

4.  })

5.  script\>

59body\>

通过VueRouter实例中routes数组中的每个路由匹配规则对象里面的
children属性实现路由的嵌套

![](media/24852738922765ceb006e7e1cf30f047.png)

| 31    | component: account,                      |        |
|-------|------------------------------------------|--------|
| 32    | children: [{                             |        |
| 33    | path: 'login',                           |        |
| 34    | component: login                         |        |
| 35    | }, {                                     |        |
| 36    | path: 'register',                        |        |
| 37    | component: register                      |        |
| 38    | }]                                       |        |
| 39    | }],                                      |        |
| 40    | routerActiveClass: 'myrouteractiveclass' |        |
| 41    | })                                       |        |
| 42 43 | var vm = new Vue({                       |        |
| 44    | el: "\#app",                             |        |
| 45    | data: {},                                |        |
| 46    | methods: {},                             |        |
| 47    | router: accountRouter                    |        |
| 48    | })                                       |        |
| 49    | \</ script\>                             |        |
|       | \</                                      | body\> |

>   50

1.  使用路由实现经典布局

![](media/564926b443b6edb0a03dd7e9dc990725.png)

| 59 |
|----|


>   60

>   61

>   62

>   63

>   64

>   65

>   66

>   67

>   68

>   69

>   70

>   71

>   72

>   73

>   74

>   75

>   76

>   77

>   78

>   79

>   80

>   81

>   82

>   83

>   84

>   85

>   86

>   87

>   88

| \</ |
|-----|


>   89body

\</

div\> script\> var header = { template: '\<h1
class="header"\>Header头部区域\</h1\>'

>   }

>   var left = {

template: '\<h1 class="left"\>Left左侧区域\</h1\>'

>   }

>   var main = {

template: '\<h1 class="main"\>Main主体区域\</h1\>'

>   }

>   var routerObj = new VueRouter({

routes: [{

path: "/",

components: {

'header': header,

'left': left,

'main': main

} }] })

>   var vm = new Vue({

el: "\#app",

data: {},

methods: {},

router: routerObj

>   }) script\>

>   \>

|     | \< |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|-----|----|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| \</ |    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |

二十三、Vue中的watch属性
========================

1.  使用keyup方法实现名称案例

| /\>= 6 \<input type="text" class="form‐control" v‐model="secondname" \@key up="getFullName" 7 |
|-----------------------------------------------------------------------------------------------|
| /\>                                                                                           |
| \</                                                                                           |
| \</                                                                                           |
| \</                                                                                           |

2.  \<input type="text" class="form‐control" v‐model="fullname"

3.  div\>

4.  \<script\>

5.  var vm = new Vue({

6.  el: "\#app",

7.  data: {

8.  firstname: '',

9.  secondname: '',

10. fullname: ''

11. },

12. methods: {

13. getFullName() {

14. this.fullname = this.firstname + "‐‐" + this.secondn ame

15. }

16. } 23 })

24 script\>

25body\>

1.  使用Vue实例中的watch属性改造名称案例

使用Vue中的watch属性可以监听data中任意一个数据的变化，只要被监听的数据值发生变化，就会执行对应的function

| //使用Vue中的watch属性可以监听data中任意一个数据的变化，只要被监听的数据值发生变化，就会执行对应的function |
|------------------------------------------------------------------------------------------------------------|
| \</                                                                                                        |
| \</                                                                                                        |

1.  watch: {

2.  //如下，对data中的firstname和secondname两个数据进行监听

3.  "firstname": function(newval, oldval) {

4.  this.fullname = newval + "‐‐" + this.secondname

5.  },

6.  "secondname": function(newval, oldval) {

7.  this.fullname = this.firstname + "‐‐" + newval

8.  }

9.  } 25 })

26 script\>

27body\>

1.  使用watch属性检测路由的变化

| var vm = new Vue({ |
|--------------------|


    1.  el: "\#app",

        1.  data: {},

            1.  methods: {},

            2.  router: routerObj,

            3.  watch: {

            4.  '\$route.path': function(newval, oldval) {

            5.  console.log(newval);

            6.  if (newval == '/login') {

            7.  console.log("欢迎进入登录界面")

            8.  } else if (newval == "/register") {

            9.  console.log("欢迎进入注册界面");

            10. }

            11. }

            12. },

            13. })

| \</ |
|-----|


    2.  script\>

| 43 | \</ | body\> |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|----|-----|--------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


二十四、Vue中computed（计算属性）属性

| \<body\> |
|----------|


1.  \<div id="app"\>

    3

    1.  \<input type="text" v‐model="firstname"\> +

        1.  \<input type="text" v‐model="middlename"\> +

            1.  \<input type="text" v‐model="lastname"\> =

            2.  \<input type="text" v‐model="fullname"\>

| \</ |
|-----|


    2.  div\>

        9

        1.  \<script\>

            1.  // 创建 Vue 实例，得到 ViewModel

            2.  var vm = new Vue({

            3.  el: '\#app',

            4.  data: {

            5.  firstname: '',

            6.  lastname: '',

            7.  middlename: ''

            8.  },

            9.  methods: {},

            10. computed: { // 在 computed 中，可以定义一些 属性，这些属性，叫

            >   做 【计算属性】， 计算属性的，本质，就是
            >   一个方法，只不过，我们在使用 这些计算属性

| 的时候，是把 它们的 名称，直接当作 属性来使用的；并不会把 计算属性，当作方法去调用； 21 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
|-----------------------------------------------------------------------------------------|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| \</                                                                                     |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
| \</                                                                                     |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |

2.  // 注意1： 计算属性，在引用的时候，一定不要加 () 去调用，直接把它 当作 普通
    属性去使用就好了；

3.  // 注意2： 只要 计算属性，这个 function 内部，所用到的 任何 data
    中的数据发送了变化，就会 立即重新计算 这个 计算属性的值

4.  // 注意3： 计算属性的求值结果，会被缓存起来，方便下次直接使用； 如果
    计算属性方法中，所以来的任何数据，都没有发生过变化，则，不会重新对
    计算属性求值；

5.  'fullname': function() {

6.  console.log('ok')

7.  return this.firstname + '‐' + this.middlename + '' + this.lastname

8.  }

9.  } 30 });

31 script\>

32body\>

1、computed、methods、watch三者对比

1.computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用；

>   2.methods方法表示一个具体的操作，主要书写业务逻辑；

3.watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操

作；可以看作是computed和methods的结合体；

二十五、使用Vue中render属性渲染组件
===================================

注意：使用Vue实例中的render属性渲染组件时，会直接替换Vue中el属性指向的容器，而不是在容器里面添加节点。

| var vm = new Vue({ |
|--------------------|
| \</                |
| \</                |

1.  el: '\#app',

2.  data: {},

3.  methods: {},

4.  render: function (createElements) { // createElements 是一个
    方法，调用它，能够把 指定的 组件模板，渲染为 html 结构

5.  return createElements(login)

6.  // 注意：这里 return 的结果，会 替换页面中 el 指定的那个 容器

7.  }

8.  });

9.  script\>

19body\>

二十六、webpack
===============

1.  nrm

作用：nrm提供了一些 常见的NPM镜像包地址，
能够让我们快速的切换安装包时候的服务器地址。

1.  镜像

原来的包一开始只是在国外的NPM服务器，但是由于网络原因，经常访问不到，这时候我们可以在国内，创建一个和官网一样的的NPM服务器，但是数据都是从国外服务器上拿过来的，除此之外，使用方法完全一样。

1.  nrm使用的使用

2.  、运行npm i nrm -g 全局安装nrm包

3.  、使用nrm ls查看当前所有可用的镜像源地址，以及当前所使用的的镜像源地址。

4.  、使用nrm use npm 或者 nrm use taobao 切换不同的镜像源地址注意： nrm
    只是单纯的提供了几个常用的 下载包的 URL地址，并能够让我们在 这几个
    地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的 装包工具，都是
    npm

5.  webpack的使用

    1.  问题引入

>   4.1.1、在网页中会引用哪些常见的静态资源？

>   JS

.js .jsx .coffee .ts（TypeScript 类 C\# 语言）

>   CSS

>   .css .less .sass .scss

>   Images

>   .jpg .png .gif .bmp .svg 字体文件（Fonts）

>   .svg .ttf .eot .woff .woff2 模板文件

>   .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】

>   4.1.2、网页中引入的静态资源多了以后有什么问题？？？

1.  网页加载速度慢， 因为 我们要发起很多的二次请求；

2.  要处理错综复杂的依赖关系

>   4.1.3、如何解决上述两个问题

1.  合并、压缩、精灵图、图片的Base64编码

2.  可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系；

4.1.4、 终完美解决方案

1.  使用Gulp， 是基于 task 任务的；

2.  使用Webpack， 是基于整个项目进行构建的；

>   借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。

根据官网的图片介绍webpack打包的过程

1.  webpack介绍

webpack是前端的一个项目构建工具，他是基于Node.js开发的构建工具。

1.  webpack的两种安装方式

2.  运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令

3.  在项目根目录中运行npm i webpack --save-dev安装到项目依赖中

>   4.4、使用webpack构建项目

1.  项目初始化：在项目的根目录下，打开控制台，执行 npm init ­y 命令初始化项目。

2.  下载安装相应的依赖、插件等。例如：安装jquery

>   在入口文件index.js中引入：import \$ from 'jquery' 然后在控制台执行：npm i
>   jquery ­S 下载安装jquery

>   注意：import \*\* from \*\*\* 使我们ES6中导入模块的方式

1.  指定项目入口：在项目根目录下，必须有dist目录和

src目录，并且src目录下必须有index.js
因为webpack4版本后，是以.\\src\\index.js作为项目的入

口文件

1.  指定webpack的mode，可以在控制台执行命令：webpack ­­mode

development 或者 webpack ­­mode production

>   也可以在package.json文件中的“scripts”节点中添加下

面两居代码：

>   "dev": "webpack ­­mode development",

>   "build": "webpack ­­mode production",

>   如果不行：可先在package.json中添加，在执行webpack

­­mode development或者webpack ­­mode production

1.  控制台再执行npm run dev 或者 npm run prod 即可

在dist文件下生成main.js文件

>   4.5、webpack的作用

1.  、webpack能处理JS文件之间的相互依赖关系

2.  、webpack能处理JS的兼容问题，吧高级的 浏览器不识别的语法 转为低级的
    浏览器识别的语法

3.  webpack配置文件的基本使用（webpack.config.js）

（1）、在项目的根路径下创建webpack.config.js文件，在里面做一些简单的配置

| //这个配置文件其实就是一个 JS文件，通过NODE中的模块操作，向外暴露了一个 配置对象 |
|----------------------------------------------------------------------------------|


1.  const path = require("path");

3

1.  module.exports = {

2.  //在这个对象里指定 打包文件的 入口和出口以及文件名称

3.  entry: path.join(__dirname, './src/index.js'), //打包文件的入口 以及 名称

4.  output: {

5.  path: path.join(__dirname, './dist'), // 指定打包好的文件 输出到那个目录里去

6.  filename: 'bundle.js' //输出的文件名称

7.  }

8.  }

9.  webpack-dev-server工具的使用

    1.  使用webpack-dev-server工具，来实现项目自动编译打包的过程。

    2.  运行 npm i webpack-dev-server -D 把这个工具安装到项目的本地开发依赖

    3.  安装完毕后，这个 工具的用法， 和 webpack 命令的用法，完全一样

注意：由于webpack-dev-server工具是在项目本地中的安装

的，所以无法把他当做脚本命令在终端中执行，只有那些安装在全局的

（-g）的工具，才能在终端中执行。

1.  由于webpack-dev-server是依赖于webpack的，webpack-dev-server要想正常运行，要求在本地项目中必须安装
    webpack cnpm i webpack -D

注意：在webpack4之后，还需要在本地安装webpack-cli工具，否则执行报错

1.  webpack-dev-server帮我们打包生成好的入口文件

（bundle.js），并没有放到物理磁盘上，二是直接托管到了 电脑的内存中，所以，我们在
项目根目录中，根本找不到 这个打包好的 bundle.js;

1.  我们可以认为， webpack-dev-server 把打包好的 文

件，以一种虚拟的形式，托管到了 咱们项目的 根目录中，虽然我们看

不到它，但是，可以认为， 和 dist src node_modules 平级，有一个看不见的文件，叫做
bundle.js

1.  所以我们在index.html文件中直接饮用虚拟的bundle.js文件，不需要在引入磁盘中的bundle.js文件了。

2.  所有工具安装完成后，控制台执行; webpack-devserver或者npm run
    dev2，即可运行webpack-dev-server工具

了。他会一直监听文件的内容的变化，随时进行编译和打包，用户也不用再刷新浏览器了。

注意：此处是将webpack-dev-server配置到package.json文

件中的“scripts”中，使用dev2来代替webpack-dev-server。运行 npm run dev2
其实就是运行了 webpack-dev-server命令

>   3 "version": "1.0.0",

19 "webpack": "\^4.42.1", 20 "webpack‐cli": "\^3.3.11", 21 "webpack‐dev‐server": "\^3.10.3"
-------------------------------------------------------------------------------------------

>   22 }

1.  pack-dev-server工具常用的命令参数

    1.  webpack-dev-server --open： --open表示，项目编译打

包完成后，自动打开浏览器

1.  webpack-dev-server --open --port 3000： --port

3000，项目运行端口为3000

1.  webpack-dev-server --open --port 3000 -contentBase src：--contentBase
    src，表示项目启动后，自动定位

到src目录下，因为index.html在src下放着，所以会自动打开 index.html界面

>   7.3、webp-dev-server --open --port 3000 --contentBase

src --hot：
--hot:表示热部署，热加载，可实现浏览器无刷新加载，使用它不会每次都重新生成一个新的文件，而是打补丁

### 1 "scripts": { 2 "dev": "webpack ‐‐mode development", 3 "dev2": "webpack‐dev‐server ‐‐open ‐‐port 3000 ‐‐contentBase sr c ‐‐hot", 4 "build": "webpack ‐‐mode production", 5 "test": "echo \\"Error: no test specified\\" && exit 1" 6 },

8、webpack-dev-server工具配置命令参数的第二种方式（了解即可）

>   除了上述在package.json文件中webpack-dev-server命令后面配置参数外，还有第二

种参数配置方式，就是在webpack.config.js文件中配置在webpack.config.js文件中的module.exports中添加devServer模块，在里面添加添加配置

>   devServer: {

>   open: true, //自动打开浏览器

>   port: 3000, //这是启动时候的运行端口

>   contentBase: 'src', //指定托管的根目录

>   //启用webpack-dev-server热更新第一步

>   hot: true //启用热更新

>   },

>   其中启用webpack-dev-server的热更新hot比较麻烦，总共有三步：

1.  、在devServer节点中添加 hot:true

2.  、在webpack-dev-server的配置文件中webpack.config.js中引入webpack：

>   //这是启用热更新的第二部

>   const webpack = require('webpack');

1.  、在module.exports中添加plusgins[]节点，添加

>   HotModuleReplacementPlugin插件，直接new一个对象即可

>   //webpack的插件

>   plugins: [

>   new webpack.HotModuleReplacementPlugin() //这是启用热更

>   新的第三步，new一个热更新的模块对象

>   ]

1.  new webpack.HotModuleReplacementPlugin() //这是启用热更新的第三步，
    new一个热更新的模块对象

2.  ]

3.  }

4.  webpack插件html-webpack-plugin配置启动页面作用：

    1.  、基于物理磁盘上的index.html，在内存里的生成同样的index.html

    2.  、自动在生成的index.html中巴打包的bundle.js文件引入进去

    3.  安装html-webpack-plugin插件使用命令：npm i html-webpack-plugin -D
        或者cnpm i html-webpack-plugin

\-D

1.  在webpack配置文件webpack.config.js文件中导入插件

>   1 //导入在内存里生成index.html的插件

### 2 const htmlWebpackPlugin = require("html‐webpack‐plugin");

>   9.3、在插件节点plugins[]中添加这个插件

1.  //webpack的插件

2.  plugins: [

3.  new webpack.HotModuleReplacementPlugin(), //这是启用热更新的第三步，new
    一个热更新的模块对象

4.  new htmlWebpackPlugin({ //在plugins数组节点中添加html‐webpack‐plugin插件
    并添加相应的配置

5 //指定模板页面 未来会根据指定路径的模板页面 在内存里生成同样的页面
--------------------------------------------------------------------

1.  template: path.join(__dirname, './src/index.html'),

2.  filename: 'index.html' // 指定内存里生成的页面的名称

3.  })

### 9 ]

注意：当使用了html-webpack-plugin插件后，我们不用去手动处理
bundle.js文件了，因为这个插件在内存里生成index.html的同时，会自动帮我们在页面里创建一个合适的script标签，引用bundle.js文件

1.  webpack处理样式文件

webpack默认只能打包处理JS类型的文件，不能处理非JS类型的文件，如果想要处理非JS
类型的文件，需要手动安装一些第三方的loader。

>   10.1、webpack处理.css类型的文件

1.  、创建.css文件

2.  、在index.js文件中使用import语法引入css文件: import './css/index.css'

>   1 //使用import语法导入css文件

### 2 import './css/index.css'

1.  、安装两个loader：style-loader，css-loader 安装命令: cnpm i styleloader
    css-loader -D

2.  、打开webpack配置文件webpack.config.js，在里面module.exports里面

新增一个配置节点module，是一个对象。这个对象里有一个rules属性，是一个数组，在这个数组里添加第三方文件的匹配和处理规则。

1 //module节点用于配置加载所有的第三方模块的加载器
--------------------------------------------------

1.  module: {

2.  rules: [ //第三方模块的匹配规则

### 4 { test: /\\.css\$/, use: ['style‐loader', 'css‐loader'] } //配置处理.css文件的第三方loader

#### 5 ] 6 }

>   10.2、webpack处理.less类型的样式文件

1.  、创建.less文件

2.  、在index.js文件总引入.less文件，使用import语法。import

'./css/index.less'

1.  //使用import语法导入css文件

2.  import './css/index.css'

3.  //使用import语法导入.less文件

### 4 import './css/index.less'

1.  、安装处理.less文件的第三方loader： less-loader . npm i less-loader -

D。注意：在安装less-loader时，会提示less-loader依赖于less，所以还要安装

less。npm i less -D

1.  、在rules属性下面，添加.less文件的匹配和处理规则

1 //module节点用于配置加载所有的第三方模块的加载器
--------------------------------------------------

1.  module: {

2.  rules: [ //第三方模块的匹配规则

### 4 { test: /\\.css\$/, use: ['style‐loader', 'css‐loader'] }, // 配置处理.css文件的第三方loader 5 { test: /\\.less\$/, use: ['style‐loader', 'css‐loader', 'less

>   ‐loader'] } //配置处理.less文件的第三方loader

#### 6 ] 7 }

>   10.3、webpack处理.scss类型的样式文件

1.  、创建.scss文件

2.  、在index.js文件总引入.scss文件，使用import语法。import

'./css/index.scss'

1.  //使用import语法导入css文件

2.  import './css/index.css'

3.  //使用import语法导入.less文件

4.  import './css/index.less'

5.  //使用import语法导入.less文件

### 6 import './css/index.scss'

1.  、安装安装处理.scss文件的第三方loader： sass-loader . npm i sass-loader
    -D。注意：在安装 sass-loader，可能还需要安装node-sass。

2.  、在rules属性下面，添加.scss文件的匹配和处理规则

1 //module节点用于配置加载所有的第三方模块的加载器
--------------------------------------------------

1.  module: {

2.  rules: [ //第三方模块的匹配规则

### 4 { test: /\\.css\$/, use: ['style‐loader', 'css‐loader'] }, // 配置处理.css文件的第三方loader 5 { test: /\\.less\$/, use: ['style‐loader', 'css‐loader', 'less ‐loader'] }, //配置处理.less文件的第三方loader 6 { test: /\\.scss\$/, use: ['style‐loader', 'css‐loader', 'sass

>   ‐loader'] } //配置处理.scss文件的第三方loader

#### 7 ] 8 }

11、webpack处理图片和字体的url路径

>   默认情况下，webpack 无法 处理文件中的 url 地址，不管是图片还是 字体库，

只要是 URL 地址，都处理不了。比如css文件中图片路径、字体库路径等等。

>   如果想处理文件中的url路径地址，需要引入第三方loader来进行处理：url-loader

和file-loader。 npm i url-loader file-loader
-D。其中file-loader是url-loader内部依赖

的不用去配置文件中配置

1.  、安装url-loader和file-loader。 npm i url-loader file-loader -D。其中

file-loader是url-loader内部依赖的不用去配置文件中配置

1.  、在webpack.config.js中添加匹配和处理规则注意：loader后面是可以加参数的，具体的传参方法和url传参方法一样。使

用?和&拼接字符串的方式

### 1 //module节点用于配置加载所有的第三方模块的加载器

1.  module: {

2.  rules: [ //第三方模块的匹配规则

3.  { test: /\\.css\$/, use: ['style‐loader', 'css‐loader'] },
    //配置处理.css文件的第三方loader

4.  { test: /\\.less\$/, use: ['style‐loader', 'css‐loader', 'lessloader'] },
    //配置处理.less文件的第三方loader

5.  { test: /\\.scss\$/, use: ['style‐loader', 'css‐loader', 'sassloader'] },
    //配置处理.scss文件的第三方loader

7 //这是配置处理图片路径的loader。后面的参数：limit=7631是图片大小，如果引用的图片大于等于7631byte，单位是byte， 8 //则不会被转为base64格式的字符串，如果图片大小小于7631byte，则会被转为 base64的字符串
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  //name=是指定图片的名称。name=[hash:8]‐[name].[ext]表示：图片名称由：8位哈希值‐原图片名称.原图片后缀拼成的

2.  { test: /\\.(jpg\|png\|jpeg\|gif\|bmp)\$/, use: 'url‐loader?limit=
    7631&name=[hash:8]‐[name].[ext]' },

3.  //处理字体文件的loader匹配和处理对象

12 { test: /\\.(ttf\|eot\|svg\|woff\|woff2)/, use: 'url‐loader' }
-----------------------------------------------------------------

1.  ]

2.  }

3.  webpackotngugo通过babel插件来处理ES6或者ES7高级语法在 webpack
    中，默认只能处理 一部分 ES6 的新语法，一些更高

级的ES6语法或者 ES7 语法，webpack 是处理不了的；这时候，就需要 借助于第三方的
loader，来帮助webpack 处理这些高级的语法，当第三方loader 把 高级语法转为
低级的语法之后，会把结果交给 webpack 去打包到 bundle.js 中。通过 Babel
，可以帮我们将 高级的语法转换为 低级的语法。

>   12.1、webpack配置babel（三个步骤）

1、在 webpack 中，可以运行如下两套 命令，安装两套包，去安装 Babel 相关的
loader功能：

1.  第一套包： cnpm i babel-core babel-loader babel-plugintransform-runtime -D

2.  第二套包： cnpm i babel-preset-env babel-preset-stage-0 -D

>   2、打开 webpack 的配置文件，在 module 节点下的 rules 数组中，添加一个 新的
>   匹配规则：

1.  { test:/\\.js\$/, use: 'babel-loader', exclude:/node_modules/ }

2.  注意： 在配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过
    exclude 选项排除掉：原因有俩：

2.2.1 如果 不排除 node_modules， 则Babel 会把 node_modules 中所

>   有的 第三方 JS 文件，都打包编译，这样，会非常消耗CPU，同时，打包速度非常慢；

2.2.2 哪怕， 终，Babel 把 所有 node_modules 中的JS转换完毕了，

>   但是，项目也无法正常运行！

>   3. 在项目的 根目录中，新建一个 叫做 .babelrc 的Babel
>   配置文件，这个配置文件，属于JSON格式，所以，在写 .babelrc
>   配置的时候，必须符合JSON语法规范： 不能写注释，字符串必须用双引号

3.1 在 .babelrc 写如下的配置： 大家可以把 preset 翻译成 【语法】 的意思

>   {

>   "presets": ["env", "stage-0"], "plugins": ["transform-runtime"]

二十七webpack构建的项目中使用Vue进行开发
========================================

>   1、在项目中安装Vue包

>   1 cnpm i vue ‐D

>   2、在index.js中引入Vue的包

| \* (2)、不使用 import Vue from 'vue'，直接使用 import Vue from '../node\_ modules/vue/dist/vue.js' |
|----------------------------------------------------------------------------------------------------|
| \*/                                                                                                |

1.  \* （3）、在webpack的配置文件webpack.config.js中，为vue.js起别名

2.  \* resolve: {

3.  alias: { // 修改 Vue 被导入时候的包的路径

4.  "vue\$": "vue/dist/vue.js"

5.  }

6.  }

7.  \*

28

1.  import Vue from 'vue';

2.  // import Vue from '../node_modules/vue/dist/vue.js'

31

1.  var vm = new Vue({

2.  el: "\#app",

3.  data: {

4.  mag: "webpack‐vue"

5.  },

6.  methods: {}

7.  })

webpack.config.js文件中：

1.  port: 3000, //这是启动时候的运行端口

2.  contentBase: 'src', //指定托管的根目录

3.  //启用webpack‐dev‐server热更新第一步

4.  hot: true //启用热更新

5.  },

6.  //webpack的插件

7.  plugins: [

25 new webpack.HotModuleReplacementPlugin(), //这是启用热更新的第三步，new一个热更新的模块对象
----------------------------------------------------------------------------------------------

>   26 new htmlWebpackPlugin({ //在plugins数组节点中添加html‐webpack‐plug in插件
>   并添加相应的配置

### 27 //指定模板页面 未来会根据指定路径的模板页面 在内存里生成同样的页面

1.  template: path.join(__dirname, './src/index.html'),

2.  filename: 'index.html' // 指定内存里生成的页面的名称

3.  })

4.  ],

### 32 //module节点用于配置加载所有的第三方模块的加载器

1.  module: {

2.  rules: [ //第三方模块的匹配规则

3.  { test: /\\.css\$/, use: ['style‐loader', 'css‐loader'] },
    //配置处理.css文件的第三方loader

4.  { test: /\\.less\$/, use: ['style‐loader', 'css‐loader', 'less ‐loader'] },
    //配置处理.less文件的第三方loader

5.  { test: /\\.scss\$/, use: ['style‐loader', 'css‐loader', 'sass

>   ‐loader'] }, //配置处理.scss文件的第三方loader

### 38 //这是配置处理图片路径的loader。后面的参数：limit=7631是图片大小，如果引用的图片大于等于7631byte，单位是byte， 39 //则不会被转为base64格式的字符串，如果图片大小小于7631byte，则会被转为 base64的字符串

1.  //name=是指定图片的名称。name=[hash:8]‐[name].[ext]表示：图片名称由：8位哈希值‐原图片名称.原图片后缀拼成的

2.  { test: /\\.(jpg\|png\|jpeg\|gif\|bmp)\$/, use: 'url‐loader?limit=
    7631&name=[hash:8]‐[name].[ext]' },

### 42 //处理字体文件的loader匹配和处理对象

1.  { test: /\\.(ttf\|eot\|svg\|woff\|woff2\|otf)/, use: 'urlloader' },

2.  { test: /\\.js\$/, use: 'babel‐loader', exclude: /node_module s/ } // 配置
    Babel 来转换高级的ES语法

3.  ]

4.  },

5.  resolve: {

6.  alias: { // 修改 Vue 被导入时候的包的路径

### 49 "vue\$": "vue/dist/vue.js"

1.  }

2.  }

>   52

>   53 }

1.  在webpack和Vue结合时，使用默认webpack导入的vue组件进行组件渲染

>   这时候必须使用到Vue中的render函数来渲染组件

1.  创建.vue组件文件

2.  将.vue组件文件导入到index.js文件中

3.  使用render函数来进行组件渲染

>   注意：webpack默认是不能解析.vue文件的，所以必须安装第

>   三方的loader来解析.vue文件：cnpm i vue-loader vuetemplate-compiler
>   -D，同时在webpack.config.js文件中添

>   加.vue文件的匹配和处理规则

>   注意：在vue-loader\@15版本后，除了必须带有

>   VueLoaderPlugin 之外，还需另外单独配置css-loader。所以在
>   webpack.config.js文件中添加下面两句：

>   const VueLoaderPlugin = require('vue-loader/lib/plugin');

>   new VueLoaderPlugin() //这是配置vue-loader插件

#### 1 //这个配置文件其实就是一个 JS文件，通过NODE中的模块操作，向外暴露了一个 配置对象

1.  output: {

2.  path: path.join(__dirname, './dist'), // 指定打包好的文件 输出到那个目录里去

3.  filename: 'bundle.js' //输出的文件名称

4.  },

#### 18 devServer: { //这是配置dev‐server命令参数的第二种方式，相对来说比较麻烦

1.  open: true, //自动打开浏览器

2.  port: 3000, //这是启动时候的运行端口

3.  contentBase: 'src', //指定托管的根目录

4.  //启用webpack‐dev‐server热更新第一步

5.  hot: true //启用热更新

6.  },

7.  //webpack的插件

8.  plugins: [

27 new webpack.HotModuleReplacementPlugin(), //这是启用热更新的第三步，new一个热更新的模块对象
----------------------------------------------------------------------------------------------

>   28 new htmlWebpackPlugin({ //在plugins数组节点中添加html‐webpack‐plug in插件
>   并添加相应的配置

### 29 //指定模板页面 未来会根据指定路径的模板页面 在内存里生成同样的页面

1.  template: path.join(__dirname, './src/index.html'),

2.  filename: 'index.html' // 指定内存里生成的页面的名称

3.  }),

33 new VueLoaderPlugin() //这是配置vue‐loader插件
-------------------------------------------------

>   34 ],

### 35 //module节点用于配置加载所有的第三方模块的加载器

1.  module: {

2.  rules: [ //第三方模块的匹配规则

3.  { test: /\\.css\$/, use: ['style‐loader', 'css‐loader'] },
    //配置处理.css文件的第三方loader

4.  { test: /\\.less\$/, use: ['style‐loader', 'css‐loader', 'less ‐loader'] },
    //配置处理.less文件的第三方loader

5.  { test: /\\.scss\$/, use: ['style‐loader', 'css‐loader', 'sass

>   ‐loader'] }, //配置处理.scss文件的第三方loader

### 41 //这是配置处理图片路径的loader。后面的参数：limit=7631是图片大小，如果引用的图片大于等于7631byte，单位是byte， 42 //则不会被转为base64格式的字符串，如果图片大小小于7631byte，则会被转为 base64的字符串

1.  //name=是指定图片的名称。name=[hash:8]‐[name].[ext]表示：图片名称由：8位哈希值‐原图片名称.原图片后缀拼成的

2.  { test: /\\.(jpg\|png\|jpeg\|gif\|bmp)\$/, use: 'url‐loader?limit=
    7631&name=[hash:8]‐[name].[ext]' },

3.  //处理字体文件的loader匹配和处理对象

46 { test: /\\.(ttf\|eot\|svg\|woff\|woff2\|otf)/, use: 'urlloader' }, 47 { test: /\\.js\$/, use: 'babel‐loader', exclude: /node_module s/ }, // 配置 Babel 来转换高级的ES语法
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  { test: /\\.vue\$/, use: 'vue‐loader' } //这是配置webpack匹配和处理.vue文件

2.  ]

3.  },

4.  resolve: {

5.  alias: { // 修改 Vue 被导入时候的包的路径

6.  //"vue\$": "vue/dist/vue.js"

7.  }

8.  }

>   56

>   57 }

3.4、使用.vue创建的组件，不能使用components属性引用，必须使用render 进行渲染

1.  var vm = new Vue({

2.  el: "\#app",

3.  data: {

### 4 msg: "webpack‐vue"

1.  },

2.  methods: {},

### 7 // 在 webpack 中，如果想要通过 .vue文件， 把一个组件放到页面中去展示，v m 实例中的 render 函数可以实现

1.  render: function(createdElement) {

2.  //createdElement是个方法

3.  return createdElement(login);

#### 11 }

1.  //render简写

2.  //render: c =\> c(login)

#### 14 })

>   4、webpack中如何使用vue总结

1.  安装vue的包： cnpm i vue -S

2.  由于 在 webpack 中，推荐使用 .vue 这个组件模板文件定义组件，所以，需要安装
    能解析这种文件的 loader cnpm i vue-loader vue-template-complier -D。同时在

>   webpack.config.js文件中配置.vue文件的匹配和处理规则，以及配置vue-loader的插件

>   const VueLoaderPlugin = require('vue-

>   loader/lib/plugin');

>   new VueLoaderPlugin() //这是配置vue-loader插件

1.  在 main.js 中，导入 vue 模块 import Vue from 'vue'

2.  定义一个 .vue 结尾的组件，其中，组件有三部分组成：

>   template script style

1.  使用 import login from './login.vue' 导入这个组件6. 创建 vm 的实例 var vm =
    new Vue({ el: '\#app', render: c =\> c(login) })

>   7. 在页面中创建一个 id 为 app 的 div 元素，作为我们 vm 实例要控制的区域；

5、export default和exports的区别在 ES6中，也通过 规范的形式，规定了 ES6 中如何
导入 和 导出 模块

ES6中导入模块，使用 import 模块名称 from '模块标识符' import '表示路径' 在 ES6
中，使用 export default 和 export 向外暴露成员：

>   export dafault：

注意： export default 向外暴露的成员，可以使用任意的变量来接收

>   注意： 在一个模块中，export default 只允许向外暴露1次注意：
>   在一个模块中，可以同时使用 export default 和

### 7 //在其他文件引用时，可用任意变量来接受

>   8 import m222 from './test.js' 9 console.log(m222);

>   export：

>   注意： 使用 export 向外暴露的成员，只能使用 { } 的形式来接

收，这种形式，叫做 【按需导出】

>   注意： export 可以向外暴露多个成员， 同时，如果某些成

员，我们在 import 的时候，不需要，则可以 不在 {} 中定义

>   注意： 使用 export 导出的成员，必须严格按照 导出时候的名

称，来使用 {} 按需接收；注意： 使用 export 导出的成员，如果 就想 换个 名称来接

收，可以使用 as 来起别名；

1.  export var title = '小星星'

2.  export var content = '哈哈哈'

>   3

### 4 //在其他文件接受时 必须用{}形式接受，而且名称必须和暴露的一样。但是可以使用as起别名

>   5 import { title as title123, content } from './test.js'

1.  webpack中使用路由vue-route

>   6.1、导入路由模块

#### 1 import VueRouter from 'vue‐router'

>   6.2、安装路由模块

>   1 Vue.use(VueRouter);

>   6.3、导入需要展示的组件

>   1 import login from './components/account/login.vue'

>   2

#### 3 import register from './components/account/register.vue'

>   6.4、创建路由对象

>   6

>   7 { path: '/login', component: login },

>   8

>   9 { path: '/register', component: register }

>   10

>   11 ]

>   12

>   13 });

>   6.5、将路由对象，挂载到 Vue 实例上

>   1 var vm = new Vue({

>   2

#### 3 el: '\#app',

>   4

>   5 // render: c =\> { return c(App) }

>   6

>   7 render(c) {

>   8

1.  return c(App);

2.  11 }, 12

### 13 router // 将路由对象，挂载到 Vue 实例上

#### 14

>   15 });

>   6.6、在 template 中，添加router-link和router-view

| 1 \<router‐link to="/login"\>登录 |
|-----------------------------------|


>   2

1.  \<router‐link to="/register"\>

    1.  5

        >   6

| \>\</ |
|-------|


    >   7 \<router‐view router‐view\>

    \</

    router‐link\>

| \</ |
|-----|


    >   router‐link\>

|   | 注册 |   |   |   |   |   |   |   |   |   |
|---|------|---|---|---|---|---|---|---|---|---|


6.7、抽离路由为单独的模块 创建router.js文件

#### 5 import goodslist from './main/GoodsList.vue'

>   6

>   7 // 导入Account的两个子组件

#### 8 import login from './subcom/login.vue' 9 import register from './subcom/register.vue'

>   10

1.  // 3. 创建路由对象

2.  var router = new VueRouter({

3.  routes: [

4.  // account goodslist

5.  {

#### 16 path: '/account',

1.  component: account,

2.  children: [

3.  { path: 'login', component: login },

4.  { path: 'register', component: register }

5.  ]

6.  },

7.  { path: '/goodslist', component: goodslist }

8.  ]

9.  })

>   26

### 27 // 把路由对象暴露出去

>   28 export default router

7、.vue文件中的css作用域的问题（scoped属性和lang属性）

| \<style lang="scss" scoped\> |
|------------------------------|


1.  /\* 普通的 style 标签只支持 普通的 样式，如果想要启用 scss 或 less ，需要为
    sty le 元素，设置 lang 属性 \*/

2.  // 只要 咱们的 style 标签， 是在 .vue 组件中定义的，那么，推荐都为 style
    开启 scoped 属性

3.  body { 5 div {

4.  font‐style: italic;

5.  }

6.  }

8、在.vue组件中使用vue-resource获取数据
---------------------------------------

8.1、运行cnpm i vue-resource -S安装模块

8.2、导入 vue­resource 组件

### 1 import VueResource from 'vue‐resource'

8.3、在vue中使用 vue­resource 组件

>   1 Vue.use(VueResource);
