# 一、netty概述


1、 NIO的类库和API繁杂，使用麻烦；需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等；

2、 需要具备其他的额外技能，要熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的NIO程序；

3、 开发工作量和难度都非常大，例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等；

4、 JDKNIO的Bug，例如臭名昭著的EpollBug，它会导致Selector空轮询，最终导致CPU100%，直到JDK1.7版本该问题仍旧存在，没有被根本解决；



# 二、netty官网

1、 https://netty.io/；

netty是一个异步的，基于事件驱动的网络应用框架。为了快速的开发高性能的服务器端和客户端。


2、 netty分成了三个部分；

3、 第一个部分；

![](assets/000/01/100/01/000/003/09-1731133536832.png)

内核： 可扩展的事件模型
交互API
零拷贝


4、 第二个部分；



![](assets/000/01/100/01/000/003/09-1731133572209.png)



支持的协议。

5、 第三个部分；


![](assets/000/01/100/01/000/003/09-1731133593862.png)


支持的传输服务。


# 三、netty说明

1、 netty是由JBOSS提供的一个Java开源框架netty提供异步的、基于事件驱动的网络应用程序框架，用以快速开发高性能、高可靠性的网络IO程序；

2、 netty可以帮助你快速、简单的开发出一个网络应用，相当于简化和流程化了NIO的开发过程；

3、 netty是目前最流行的NIO框架，netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，知名的Elasticsearch、Dubbo框架内部都采用了netty；

# 四、netty的优点

1、 netty对JDK自带的NIO的API进行了封装，解决了上述问题；

2、 设计优雅：适用于各种传输类型的统一API阻塞和非阻塞Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池；

3、 使用方便：详细记录的Javadoc，用户指南和示例；没有其他依赖项，JDK5（netty3.x）或6（netty4.x）就足够了；

4、 高性能、吞吐量更高；延迟更低；减少资源消耗；最小化不必要的内存复制；

5、 安全：完整的SSL/TLS和StartTLS支持；

6、 社区活跃、不断更新；版本迭代周期短，发现的Bug可以被及时修复，同时，更多的新功能会被加入；


# 五、netty版本说明


1、 netty版本分为：netty3.x和netty4.x、netty5.x；

2、 netty3.x太老了，不使用netty5.x出现重大Bug，已经被官网废弃了目前推荐使用的是netty4.x的稳定版本；

3、 目前使用netty4.1.x版本；


# 六、线程模型基本介绍

1、 不同的线程模型，对程序的性能有很大影响，为了搞清netty线程模型，我们来系统的讲解下各个线程模型，最后看看netty线程模型有什么优越性；

2、 目前存在的线程模型有；

    传统阻塞I/O服务模型
    Reactor模式

3、 根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现；

    1、单Reactor单线程
    2、单Reactor多线程
    3、主从Reactor多线程

4、 netty线程模式（netty主要基于主从Reactor多线程模型做了一定的改进，其中主从Reactor多线程模型有多个Reactor）；

# 七、传统阻塞I/O服务模型

## 1、 工作原理图；


![](assets/000/01/100/01/000/003/09-1731134016412.png)

黄色框表示对象，蓝色的框表示线程，白色的框表示方法（API）

## 2、 模型特点；

    1、采用阻塞IO模式，获取输入的数据
    2、每个连接都需要独立的线程完成数据的输入，业务处理，数据的返回

## 3、 问题分析；

    1、当并发数很大时，就会创建大量的线程，占用很大的系统资源
    2、连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在read操作上，造成线程资源浪费



# 八、Reactor模式

针对传统阻塞I/O服务模型的2个缺点，解决方案：

## 1、 基于I/O复用模型：

    多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接，当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理；

## 2、 基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务；

## 3、 Reactor对应的叫法；

    1、反应器模式
    2、分发者模式（Dispatcher）
    3、通知者模式（notifier）

## 4、 工作原理；


![](assets/000/01/100/01/000/003/09-1731134119829.png)

    1、I/O复用结合线程池，就是Reactor模式基本设计思想
    2、Reactor模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）
    3、服务器端程序处理传入的多个请求，并将它们同步分派到相应的处理线程，因此，Reactor模式也叫Dispatcher模式
    4、Reactor模式使用IO复用监听事件，收到事件后，分发给某个线程（或进程），这点就是网络服务高并发处理的关键



# 九、Reactor模式中核心组成

1、 Reactor：Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；

2、 Handlers：处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际人员Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作；


# 十、Reactor模式分类

根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现

    1、 单Reactor单线程；
    2、 单Reactor多线程；
    3、 主从Reactor多线程；