# 从Redisson源码剖析lua解决锁的原子性问题


## 数据库redis 【双写不一致】问题

![](assets/000/01/02/04/06-1610765297168.png)

> 1 解决方案1(肯定有缺陷)

 方案是 先更新数据库值，然后删除缓存中数据，等到读的时候在进行存到内存中！ok 这样就没问题了吗 ？

 ![](assets/000/01/02/04/06-1610765462615.png)

 问题就是这，等更新缓存(10) 的时候，但其实中间线程3 可能卡了一下，线程2 可能吧数据库中的值改成了6 那么，这个时候redis 缓存中的数据就是错的，6 才是对的。那么怎么办呢？


 * 延迟双删(不靠谱)

 ![](assets/000/01/02/04/06-1610767138229.png)


 但是这种sleep 时间怎么去评估呢？ 而且还有可能在sleep时间之后，又进行了更新缓存怎么办？所以不能100% 解决,也并不靠谱！！！


 * (分布式锁)内存队列(可以解决但是有性能问题)
    
 来分析一下原因是什么，原因就是这几个线程的操作（写数据,删缓存|查缓存，查数据库，更新缓存）并不是原子操作，所以让他们原子操作不就可以解决问题了吗？

 ![](assets/000/01/02/04/06-1610767563817.png)


 所以使用分布式锁锁上，就可以解决这个问题！  
 但是又会有新的问题，什么问题？如果都这样上锁，那么你的程序岂不是相当于串行执行的，性能会特别差，分布式也没有任何意义。
  加入想让系统性能也不受太大影响怎么办？ 

* 分段锁(不可以，完全不在一个琴弦上完全聊不到一个点上)

  分段锁可以添加吗这里？  不可以

* 所以这里还是用分布式锁，但是得进行优化，如何优化呢？

> 终极方案

涉及到加锁的一半都不会是最好的解决方案

![](assets/000/01/02/04/06-1610768208772.png)