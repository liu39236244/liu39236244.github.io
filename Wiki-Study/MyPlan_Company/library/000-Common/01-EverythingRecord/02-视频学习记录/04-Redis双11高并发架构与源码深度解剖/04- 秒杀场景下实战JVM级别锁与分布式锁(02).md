# 秒杀场景下实战JVM级别锁与分布式锁

## setNX 在集群下会进行请求排队

> 1 入门级别的分布式锁


![](assets/000/01/02/04/04-1610689961146.png)


> 2 如果中间抛异常释放不了锁，所以加上try finally

![](assets/000/01/02/04/04-1610690039391.png)


> 3 如果中间try 中执行过程中宕机了？咋么办

在try 中 设置一个超时时间 ，超时10秒 就释放锁

![](assets/000/01/02/04/04-1610690111088.png)

> 4 但是这两行代码，得放入到一条命令中，作为原子操作

![](assets/000/01/02/04/04-1610690182834.png)

> 5 设置锁以及设置超时时间 有api ，一下代码则可以将两行命令设置为一条命令


![](assets/000/01/02/04/04-1610690225248.png)


> 6 看似没有问题了？但是高并发情况下 ，还有一种极端情况，释放锁，可能释放第二个进程添加的锁

![](assets/000/01/02/04/04-1610690664686.png)

* 问题来了，怎么解决？

根本原因在于自己加的锁被别人进程释放了。所以每个进程开始与结束，释放自己的所就行 


![](assets/000/01/02/04/04-1610690788999.png)


> 7 还会有问题

finally 中判断完毕，没有执行释放第一个进程锁的时候，第一个进程的锁自动释放了，那么 第一个释放操作可能释放第二个进程刚加的锁

![](assets/000/01/02/04/04-1610691717857.png)

所以 finally中的判断 与 释放操作 在一个原子操作的话才可以


* 下面设置一个分锁，就是锁续命

![](assets/000/01/02/04/04-1610691935819.png)



redisson 组件实现了 续命锁中的完整逻辑

![](assets/000/01/02/04/04-1610692807681.png)

引入依赖：

![](assets/000/01/02/04/04-1610692831291.png)




![](assets/000/01/02/04/04-1610693064373.png)

> 8 修改最终版

![](assets/000/01/02/04/04-1610693196511.png)


* redis 分布式锁的原理

![](assets/000/01/02/04/04-1610693421095.png)


