# mysql 针对索引讲解


## 为什么mysql 的索引数据结构用b+树？？

### 索引

![](assets/000/01/02/06/02/01-1611144687229.png)

![](assets/000/01/02/06/02/01-1611144693054.png)

> 1 一些问题


![](assets/000/01/02/06/02/01-1611144796979.png)


* 索引是什么，索引就是帮助mysql 高效获取数据的数据结构


> 2 mysql  底层是 B+树  ，

但是有没有想过为啥不用 二叉树，或别的树据结构做索引呢？？

* 下面有一个例子，假设用二叉搜索，下面的一个单边树，其实相当于链表了。浪费了资源而且性能也没有得到显著提高生

![](assets/000/01/02/06/02/01-1611145527565.png)


> 3 平衡二叉树 (avl tree)

扭动小蛮腰(其实就是左旋、右旋)

![](assets/000/01/02/06/02/01-1611145939685.png)

![](assets/000/01/02/06/02/01-1611146066435.png)

但是问题来了。平衡二叉树查找效果翻倍，但是为什么也不用这种平衡二叉树做 为mysql 索引的数据结构呢?


* 问题来了，所以是什么影响查找次数呢，答案是 树的深度！！
     层数越多，数据越多，io就越多，

所以查询次数过多，每次跟磁盘打交道都会进行io，io是最影响效率的

这里有个问题，mysql数据怎么调用的？

![](assets/000/01/02/06/02/01-1611146246240.png)


> 4所以总结一下

二叉树 、平衡二叉树 。影响效率

1. 层数
2. 导致io多


> 5 这里，cpu每次 拿 16kb 的数据 ，每拿一次，就会有一次io

![](assets/000/01/02/06/02/01-1611146532724.png)


### B+ tree

B+ tree 与 avl 平衡二叉树有什么区别呢？

mongodb就是二叉树


* B 树 结构如下，纵向发展

![](assets/000/01/02/06/02/01-1611147198779.png)

* b+ 树 ，则是横向发展

减少了深度 ； 

mysql 用的就是定制版的 B+ tree 

![](assets/000/01/02/06/02/01-1611147506136.png)


B+树 吧所有数据都放在了叶子上 ，叶子节点之间的页 组成了链表

所以 每次拉 16KB 内容，那么 相比较b树每个节点上有数据区，关键字，下一节点指针 ，b+ 树 一次性能拿到更多的数据(而且还有可能都是索引)



## innodb myisam 两种类型的表

### myisam 索引

主键索引myisam

![](assets/000/01/02/06/02/01-1611148738108.png)

非主键

![](assets/000/01/02/06/02/01-1611148814339.png)

> 1 MYD 存放数据在磁盘的那个位置

![](assets/000/01/02/06/02/01-1611148913639.png)

### innodb 数据索引


> 1 主键索引

![](assets/000/01/02/06/02/01-1611149034899.png)



> 2 非主键索引

![](assets/000/01/02/06/02/01-1611149066518.png)


### 区别：

可见 myisam innodb 

myisam : 底层两个文件 
    1. 真正的数据
    2. 索引

innodb ：
    1. 底层一个文件
    2. 而且主键索引作为聚集索引，叶子节点底层直接存储的是数据的值；非主键索引 叶子节点记录的是每一行记录的id ，然后在返回id 聚集索引再次去查一下主键索引



> innodb 类型表

只有主键是聚集索引，因为b+ 树叶子存储区没有挂载地址，而是真正数据

> myisam 、
稀疏索引：因为主键 /非主键 索引都是记录的地址值，数据在磁盘的地址值

### 数据存储在哪？

![](assets/000/01/02/06/02/01-1611148530268.png)

![](assets/000/01/02/06/02/01-1611148607369.png)


### 那一列适合做索引


姓名；年龄；性别；区号 ；

肯定是选择姓名;

所以选择条件是什么呢？
    考虑离散型

> 1 联合索引

* 比如下面三列创建联合索引，其实相当于建立了三个索引

![](assets/000/01/02/06/02/01-1611149687350.png)


* 所以 如果第一列条件不是name的话就不会走索引
最左匹配原则

![](assets/000/01/02/06/02/01-1611149840978.png)


> 2 案例

![](assets/000/01/02/06/02/01-1611149925769.png)

> 

2

![](assets/000/01/02/06/02/01-1611150044978.png)



> 用两列

![](assets/000/01/02/06/02/01-1611150368549.png)

>  1 lie 

![](assets/000/01/02/06/02/01-1611150447589.png)

> 0 列

![](assets/000/01/02/06/02/01-1611150474089.png)

> 2 列

优化器，优化器会为了走索引，会变化 and 的条件先后顺序
![](assets/000/01/02/06/02/01-1611150548469.png)


> 总结

![](assets/000/01/02/06/02/01-1611150660770.png)


> 那个最快


4 因为 4 会走 name 索引 ，而不用回走 id 索引 （回表操作），其他三条语句都需要回调主键索引，

![](assets/000/01/02/06/02/01-1611150806259.png)



* 为啥不要用select * from ？  因为 可能不走索引，甚至回表


### 遗留问题


![](assets/000/01/02/06/02/01-1611151141570.png)

如果没有创建主键 ，那么mysql 会创建一个隐形的索引，占用 6kb，自己创建的占用 4KB，因为 innodb 不创建索引的话，我们知道叶子结点
存储的都是挂载的数据

![](assets/000/01/02/06/02/01-1611151374325.png)

![](assets/000/01/02/06/02/01-1611151530838.png)


* synchronized

hashtable 比hashmap 线程安全，


* synchronized 雪花算法
