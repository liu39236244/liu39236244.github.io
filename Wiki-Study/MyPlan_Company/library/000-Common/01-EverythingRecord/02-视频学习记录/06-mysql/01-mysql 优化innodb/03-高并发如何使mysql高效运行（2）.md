# 高并发如何使mysql高效运行2

## 执行一条sql语句 

mysql 会从 buffer pool (相当于数组)中 

![](assets/000/01/02/06/01/03-1611058811442.png)


> 1 innerdb 数据库开启之后会开辟一个128MB的 buffer pool 块

![](assets/000/01/02/06/01/03-1611058989995.png)



但是 buffer pool 中 可能会有数据又持久化到磁盘中，所以就会出现部分空间空出来


> 2 free链表

![](assets/000/01/02/06/01/03-1611059264432.png)

有多少页就有多少个控制块，主要是快速查找到空白的区域，使用空出来的 页空间的同时，控制块会从链表上删除。这就是free 链表做的事

![](assets/000/01/02/06/01/03-1611059563084.png)

> 3 更新操作脏页

如果有修改，则会被标记为脏页，就是数据更新之后不会立即持久化到磁盘；mysql 后台会有定时任务去定时持久化

![](assets/000/01/02/06/01/03-1611059794955.png)


> 4 flush 链表

但是什么时候去持久化的时候，那么多页，要一个一个找多浪费性能，所以还有一个类似于free链表的链表，记录了那些页是脏页；等到脏页持久之后，页就不是脏页了，flush 链表中记录指针的块也会被删除

> 5 buffer pool 淘汰机制(lru  : 最近 最少 不是热点数据)

加入 空间满了，有新的页进来怎么办，就会进行淘汰机制，lru 链表；
新加入的页会放在链表头部


![](assets/000/01/02/06/01/03-1611060358163.png)


> 6 全表扫描，导致buffer pool 重新刷新

比如临时执行了select * from tableA ， buffer pool 里面的数据就会被大换血，这是不是问题


![](assets/000/01/02/06/01/03-1611060861812.png)


> 7 升级版的 lru链表 解决刚才大换血的场景； 数据区分，热数据冷数据 ，热数据 70 %  冷数据 30% 

![](assets/000/01/02/06/01/03-1611060919554.png)

![](assets/000/01/02/06/01/03-1611061246244.png)

## redo log 

记录的是物理位置某一页的地址的哪些数据进行了修改

![](assets/000/01/02/06/01/03-1611062517321.png)

redo  log  写的每一次操作 是磁盘顺序写入的，（怎么保证磁盘顺序写入？就是提前创建一个文件，然后逐行往日志文件中添加；）


> 1 redo log 为啥会有两个文件

![](assets/000/01/02/06/01/03-1611062864712.png)

* 默认就是 两个文件， 当两个文件都满了但是需要继续添加数据记录的时候，就会进行检查点


![](assets/000/01/02/06/01/03-1611063190949.png)

* 2 事务提交的时候进行持久化 redo log 中的数据

![](assets/000/01/02/06/01/03-1611063344681.png)



在redo log 之前其实还有一个  buffer 的log 存在 内存中，这里 事务提交立即持久化 redo log 中的数据 是可以配置的，mysql 默认是1 


![](assets/000/01/02/06/01/03-1611063473030.png)


##  bin log 

mysql 的 而不是 innodb 引擎的也是作为日志记录，bin log 记录的是 update 日志，所以 redo log 里面更方便，但是主从这种架构肯定用的是 bin log ，因为 redo  log 中的记录可能给冲掉；

undo log 记录反向操作， 比如事务回滚


![](assets/000/01/02/06/01/03-1611064445048.png)
 

 ## 架构图

 ![](assets/000/01/02/06/01/03-1611065173709.png)

 ![](assets/000/01/02/06/01/03-1611065211300.png)

 以及负载均衡
 