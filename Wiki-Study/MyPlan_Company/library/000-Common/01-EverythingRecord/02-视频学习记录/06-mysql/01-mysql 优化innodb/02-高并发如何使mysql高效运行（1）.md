#  高并发如何使mysql高效运行


## mysql 地层结构 b + 树


>1 创建一张表，有id 字段，会给自动生成一个索引，且插入数据的时候，会按照id 进行排序

##  一个innodb页占用 16KB


![](assets/000/01/02/06/01/02 -1610973628819.png)


innodb 页结构

![](assets/000/01/02/06/01/02 -1610973679141.png)


> 1 插入之前给排序，比如找 a= 3 找到 a=4 就不会继续找


![](assets/000/01/02/06/01/02 -1610974054540.png)

> 2 建立索引就是类似于创建页目录，

寻找在那个目录就可以使用二分查找，寻找所在的目录

![](assets/000/01/02/06/01/02 -1610974622378.png)



> 3 随着数据增多，每个页之间也会建立链表关系


![](assets/000/01/02/06/01/02-1610975387668.png)


但是链表本来就是便利慢，那这个怎么办？，空间换时间，在开辟一个页空间，记录不同页之间的关系

![](assets/000/01/02/06/01/02-1610975583648.png)

* 这就是b+ 树

![](assets/000/01/02/06/01/02-1610975712119.png)

![](assets/000/01/02/06/01/02-1610975766788.png)


### 其他字段创建索引

![](assets/000/01/02/06/01/02-1610976593198.png)



但是创建了其他联合字段的话，会增加插入操作的冗余 减少插入速度，如果想要查询所有数据怎么办， 根据bcd 索引只能查出来bcd 三个字段啊，所以在叶子上加上数据得id（根据主键id 即可查询到其他字段值）

![](assets/000/01/02/06/01/02-1610977062919.png)

* 一下 走 bcd 索引


![](assets/000/01/02/06/01/02-1610977103726.png)

> 1 最左前缀索引

如果只查 c d 字段 想要使用bcd 索引，是走不了 bcd 联合索引的，为什么？

因为创建的b+ 树， 先按照b c d 来的，目录肯定记录的是b 的最小值，你拿着 c 怎么去找 c 最小在那个页上？所以最左前缀

![](assets/000/01/02/06/01/02-1610977156758.png)



## 查询 b>1 走全表

![](assets/000/01/02/06/01/02-1610977496916.png)

走 bcd 索引 确实 可以用索引 ，但是这个是select * , 1 后面的7个值都需要回表查询每一行所有其他值，所以优化器觉得全表扫描比走bcd 索引更快，所以 查询比 b字段 比1 大的所有数据，全表扫描会更好


 > 1 查询 b>6 的


![](assets/000/01/02/06/01/02-1610977817396.png)