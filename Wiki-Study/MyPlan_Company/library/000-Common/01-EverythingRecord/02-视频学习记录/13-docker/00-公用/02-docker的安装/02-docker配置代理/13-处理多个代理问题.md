# Systemd 配置详解

## 1. `sudo systemctl daemon-reload` 的作用

**不是重新加载系统代理**，而是：

- **重新加载 systemd 管理器配置**
- 重新读取所有 `.service` 文件和 `.conf` 配置文件
- 使对服务配置文件的修改生效
- **不会重启正在运行的服务**

## 2. 创建多个配置文件的正确方式

### 可以在同一目录下创建多个 `.conf` 文件

```bash
/etc/systemd/system/docker.service.d/
├── http-proxy.conf          # 代理配置
├── limits.conf              # 资源限制配置
├── environment.conf         # 环境变量配置
└── custom-options.conf      # 自定义选项
```

### 示例：创建多个配置文件

```bash
# 1. 代理配置
sudo tee /etc/systemd/system/docker.service.d/http-proxy.conf << 'EOF'
[Service]
Environment="HTTP_PROXY=http://company-proxy:8080"
Environment="HTTPS_PROXY=http://company-proxy:8080"
Environment="NO_PROXY=localhost,127.0.0.1,.internal"
EOF

# 2. 资源限制配置
sudo tee /etc/systemd/system/docker.service.d/limits.conf << 'EOF'
[Service]
LimitNOFILE=infinity
LimitMEMLOCK=infinity
EOF

# 3. 环境变量配置
sudo tee /etc/systemd/system/docker.service.d/environment.conf << 'EOF'
[Service]
Environment="DOCKER_API_VERSION=1.40"
Environment="DOCKER_TLS_VERIFY=0"
EOF
```

## 3. 多用户代理配置方案

### 方案一：按用户创建不同配置（不推荐冲突）

```bash
# 用户A配置
sudo tee /etc/systemd/system/docker.service.d/user-a-proxy.conf << 'EOF'
[Service]
Environment="HTTP_PROXY=http://user-a-proxy:8080"
EOF

# 用户B配置
sudo tee /etc/systemd/system/docker.service.d/user-b-proxy.conf << 'EOF'
[Service]
Environment="HTTP_PROXY=http://user-b-proxy:8080"
EOF
```

**问题**：最后一个加载的配置会覆盖前面的同名环境变量。

### 方案二：使用统一的负载均衡代理（推荐）

```bash
# 统一的代理配置
sudo tee /etc/systemd/system/docker.service.d/http-proxy.conf << 'EOF'
[Service]
Environment="HTTP_PROXY=http://load-balancer:8080"
Environment="HTTPS_PROXY=http://load-balancer:8080"
Environment="NO_PROXY=localhost,127.0.0.1,10.0.0.0/8,192.168.0.0/16"
EOF
```

### 方案三：使用配置切换脚本

创建切换脚本 `/usr/local/bin/switch-docker-proxy`：

```bash
#!/bin/bash

case "$1" in
    "user-a")
        PROXY="http://user-a-proxy:8080"
        ;;
    "user-b")
        PROXY="http://user-b-proxy:8080"
        ;;
    "default"|"")
        PROXY=""
        ;;
    *)
        echo "Usage: $0 {user-a|user-b|default}"
        exit 1
        ;;
esac

# 更新代理配置
cat > /tmp/docker-proxy.conf << EOF
[Service]
Environment="HTTP_PROXY=$PROXY"
Environment="HTTPS_PROXY=$PROXY"
Environment="NO_PROXY=localhost,127.0.0.1,.internal"
EOF

sudo mv /tmp/docker-proxy.conf /etc/systemd/system/docker.service.d/http-proxy.conf
sudo systemctl daemon-reload
sudo systemctl restart docker

echo "Docker proxy switched to: $PROXY"
```

设置执行权限：

```bash
sudo chmod +x /usr/local/bin/switch-docker-proxy
```

使用方式：

```bash
sudo switch-docker-proxy user-a
sudo switch-docker-proxy user-b
sudo switch-docker-proxy default  # 清除代理
```

## 4. 验证配置加载

### 检查所有加载的配置

```bash
# 查看所有生效的环境变量
sudo systemctl show docker --property Environment

# 查看完整的服务配置
sudo systemctl cat docker

# 检查配置加载顺序
sudo systemd-analyze cat-config systemd/docker.service
```

### 检查特定配置是否生效

```bash
# 查看代理设置
docker info | grep -i proxy

# 测试网络连接
docker pull hello-world
```

## 5. 配置文件加载规则

### 加载顺序（按字母顺序）：

```bash
/etc/systemd/system/docker.service.d/
├── 00-base.conf          # 最先加载
├── 10-proxy.conf         # 其次
├── 20-limits.conf        # 再次
└── 99-custom.conf        # 最后加载，可能覆盖前面的
```

### 推荐的文件命名规范：

```bash
# 使用数字前缀控制加载顺序
sudo tee /etc/systemd/system/docker.service.d/10-http-proxy.conf << 'EOF'
[Service]
Environment="HTTP_PROXY=http://primary-proxy:8080"
EOF

sudo tee /etc/systemd/system/docker.service.d/20-fallback-proxy.conf << 'EOF'
[Service]
Environment="HTTP_PROXY_BACKUP=http://backup-proxy:8080"
EOF
```

## 6. 完整操作流程

```bash
# 1. 创建配置目录
sudo mkdir -p /etc/systemd/system/docker.service.d/

# 2. 创建代理配置
sudo tee /etc/systemd/system/docker.service.d/http-proxy.conf << 'EOF'
[Service]
Environment="HTTP_PROXY=http://your-proxy-server:8080"
Environment="HTTPS_PROXY=http://your-proxy-server:8080"
Environment="NO_PROXY=localhost,127.0.0.1,.local"
EOF

# 3. 重新加载 systemd 配置
sudo systemctl daemon-reload

# 4. 重启 Docker 服务
sudo systemctl restart docker

# 5. 验证配置
sudo systemctl show docker --property Environment
docker info | grep -i proxy
```

## 重要提醒

**多个配置文件中的同名环境变量会相互覆盖**，通常最后一个加载的会生效。对于代理配置，建议只使用一个统一的配置文件，或者使用配置切换脚本来管理不同的代理设置。
