好的，我来帮你写一个综合测试脚本，测试镜像源可用性和镜像可下载性，但不实际下载。

```bash
# 创建综合测试脚本
cat > docker_mirrors_test.sh << 'EOF'
#!/bin/bash

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 镜像源列表
mirrors=(
    "https://docker.mirrors.ustc.edu.cn|中科大"
    "https://hub-mirror.c.163.com|网易"
    "https://docker.m.daocloud.io|DaoCloud"
    "https://dockerproxy.com|DockerProxy"
    "https://docker.nju.edu.cn|南京大学"
    "https://mirror.baidubce.com|百度云"
    "https://dockerhub.azk8s.cn|Azure中国"
    "https://reg-mirror.qiniu.com|七牛云"
)

# 开发组件镜像列表
dev_images=(
    "library/nginx:latest|Nginx Web服务器"
    "library/redis:latest|Redis 缓存数据库"
    "library/mysql:8.0|MySQL 关系数据库"
    "clickhouse/clickhouse-server:latest|ClickHouse 列式数据库"
    "starrocks/starrocks:latest|StarRocks 分析数据库"
    "library/postgres:latest|PostgreSQL 数据库"
    "library/mongo:latest|MongoDB 文档数据库"
    "library/elasticsearch:7.17.0|Elasticsearch 搜索引擎"
)

# 大数据组件镜像列表
bigdata_images=(
    "apache/spark:latest|Apache Spark"
    "apache/hadoop:3|Apache Hadoop"
    "apache/kafka:latest|Apache Kafka"
    "apache/zookeeper:latest|Apache Zookeeper"
    "apache/flink:latest|Apache Flink"
    "apache/airflow:latest|Apache Airflow"
    "confluentinc/cp-kafka:latest|Confluent Kafka"
    "bitnami/spark:latest|Bitnami Spark"
    "jupyter/all-spark-notebook:latest|Jupyter Spark"
    "apache/superset:latest|Apache Superset"
    "grafana/grafana:latest|Grafana 监控"
    "prom/prometheus:latest|Prometheus 监控"
    "elastic/kibana:7.17.0|Kibana 可视化"
    "apache/dolphinscheduler:latest|DolphinScheduler"
    "apache/doris:latest|Apache Doris"
)

# 函数：测试镜像源连通性
test_mirror_connectivity() {
    local url=$1
    local name=$2
    
    echo -n "  测试 ${name} (${url}): "
    
    # 测试基本连通性
    if ! curl -s --connect-timeout 5 --max-time 10 "${url}" > /dev/null 2>&1; then
        echo -e "${RED}❌ 连接失败${NC}"
        return 1
    fi
    
    # 测试 Docker Registry API
    if curl -s --connect-timeout 5 --max-time 10 "${url}/v2/" | grep -q "registry" 2>/dev/null; then
        echo -e "${GREEN}✅ API 正常${NC}"
        return 0
    else
        echo -e "${YELLOW}⚠️  连接成功但API异常${NC}"
        return 2
    fi
}

# 函数：测试镜像是否存在（不下载）
test_image_exists() {
    local mirror_url=$1
    local image_path=$2
    local image_name=$3
    
    # 构建 manifest URL
    local manifest_url="${mirror_url}/v2/${image_path}/manifests/latest"
    
    # 测试镜像 manifest 是否存在
    if curl -s --connect-timeout 5 --max-time 10 -I "${manifest_url}" | grep -q "200 OK\|application/vnd.docker" 2>/dev/null; then
        return 0
    else
        return 1
    fi
}

# 函数：测试镜像源的镜像可用性
test_images_on_mirror() {
    local mirror_url=$1
    local mirror_name=$2
    local images_array=("$@")
    local images_array=("${@:3}")  # 从第3个参数开始是镜像数组
    
    echo -e "\n${BLUE}📋 测试 ${mirror_name} 的镜像可用性：${NC}"
    
    local success_count=0
    local total_count=${#images_array[@]}
    
    for image_info in "${images_array[@]}"; do
        local image_path=$(echo "$image_info" | cut -d'|' -f1)
        local image_desc=$(echo "$image_info" | cut -d'|' -f2)
        
        echo -n "    ${image_desc}: "
        
        if test_image_exists "$mirror_url" "$image_path" "$image_desc"; then
            echo -e "${GREEN}✅ 可用${NC}"
            ((success_count++))
        else
            echo -e "${RED}❌ 不可用${NC}"
        fi
    done
    
    echo -e "    ${YELLOW}📊 成功率: ${success_count}/${total_count} ($(( success_count * 100 / total_count ))%)${NC}"
}

# 主函数
main() {
    echo -e "${BLUE}🔍 Docker 镜像源综合测试${NC}"
    echo "========================================"
    
    # 1. 测试镜像源连通性
    echo -e "\n${YELLOW}📡 第一步：测试镜像源连通性${NC}"
    available_mirrors=()
    
    for mirror_info in "${mirrors[@]}"; do
        url=$(echo "$mirror_info" | cut -d'|' -f1)
        name=$(echo "$mirror_info" | cut -d'|' -f2)
        
        if test_mirror_connectivity "$url" "$name"; then
            available_mirrors+=("$mirror_info")
        fi
    done
    
    echo -e "\n${GREEN}✅ 可用镜像源数量: ${#available_mirrors[@]}/${#mirrors[@]}${NC}"
    
    if [ ${#available_mirrors[@]} -eq 0 ]; then
        echo -e "${RED}❌ 没有可用的镜像源，测试结束${NC}"
        exit 1
    fi
    
    # 2. 测试开发组件镜像
    echo -e "\n${YELLOW}🛠️  第二步：测试开发组件镜像可用性${NC}"
    for mirror_info in "${available_mirrors[@]}"; do
        url=$(echo "$mirror_info" | cut -d'|' -f1)
        name=$(echo "$mirror_info" | cut -d'|' -f2)
        test_images_on_mirror "$url" "$name" "${dev_images[@]}"
    done
    
    # 3. 测试大数据组件镜像
    echo -e "\n${YELLOW}📊 第三步：测试大数据组件镜像可用性${NC}"
    for mirror_info in "${available_mirrors[@]}"; do
        url=$(echo "$mirror_info" | cut -d'|' -f1)
        name=$(echo "$mirror_info" | cut -d'|' -f2)
        test_images_on_mirror "$url" "$name" "${bigdata_images[@]}"
    done
    
    # 4. 生成推荐配置
    echo -e "\n${BLUE}💡 推荐的镜像源配置：${NC}"
    echo "{"
    echo '  "registry-mirrors": ['
    
    local first=true
    for mirror_info in "${available_mirrors[@]}"; do
        url=$(echo "$mirror_info" | cut -d'|' -f1)
        if [ "$first" = true ]; then
            echo "    \"$url\","
            first=false
        else
            echo "    \"$url\","
        fi
    done
    
    echo '  ]'
    echo "}"
    
    # 5. 生成测试总结
    echo -e "\n${BLUE}📈 测试总结：${NC}"
    echo "- 总镜像源数量: ${#mirrors[@]}"
    echo "- 可用镜像源数量: ${#available_mirrors[@]}"
    echo "- 测试的开发组件: ${#dev_images[@]} 个"
    echo "- 测试的大数据组件: ${#bigdata_images[@]} 个"
    
    echo -e "\n${GREEN}✨ 测试完成！${NC}"
}

# 快速测试函数（只测试连通性）
quick_test() {
    echo -e "${BLUE}⚡ 快速连通性测试${NC}"
    echo "===================="
    
    for mirror_info in "${mirrors[@]}"; do
        url=$(echo "$mirror_info" | cut -d'|' -f1)
        name=$(echo "$mirror_info" | cut -d'|' -f2)
        test_mirror_connectivity "$url" "$name"
    done
}

# 检查参数
case "${1:-full}" in
    "quick"|"-q"|"--quick")
        quick_test
        ;;
    "full"|"-f"|"--full"|"")
        main
        ;;
    "help"|"-h"|"--help")
        echo "用法: $0 [选项]"
        echo "选项:"
        echo "  quick, -q, --quick    只测试镜像源连通性"
        echo "  full, -f, --full      完整测试（默认）"
        echo "  help, -h, --help      显示帮助信息"
        ;;
    *)
        echo "未知选项: $1"
        echo "使用 '$0 help' 查看帮助"
        exit 1
        ;;
esac
EOF

# 给脚本执行权限
chmod +x docker_mirrors_test.sh

# 创建一个简化版本的测试脚本
cat > quick_mirror_test.sh << 'EOF'
#!/bin/bash

# 简化版镜像源测试
mirrors=(
    "docker.mirrors.ustc.edu.cn|中科大"
    "hub-mirror.c.163.com|网易"
    "docker.m.daocloud.io|DaoCloud"
    "dockerproxy.com|DockerProxy"
    "docker.nju.edu.cn|南京大学"
    "mirror.baidubce.com|百度云"
    "dockerhub.azk8s.cn|Azure中国"
    "reg-mirror.qiniu.com|七牛云"
)

echo "🔍 Docker 镜像源快速测试"
echo "========================"

available_count=0
for mirror_info in "${mirrors[@]}"; do
    url=$(echo "$mirror_info" | cut -d'|' -f1)
    name=$(echo "$mirror_info" | cut -d'|' -f2)
    
    echo -n "测试 $name: "
    if curl -s --connect-timeout 3 "https://$url/v2/" > /dev/null 2>&1; then
        echo "✅ 可用"
        ((available_count++))
    else
        echo "❌ 不可用"
    fi
done

echo ""
echo "📊 结果: $available_count/${#mirrors[@]} 个镜像源可用"

# 测试几个常用镜像的存在性
if [ $available_count -gt 0 ]; then
    echo ""
    echo "🧪 测试常用镜像可下载性："
    test_images=("nginx" "redis" "mysql")
    
    for image in "${test_images[@]}"; do
        echo -n "  $image: "
        if timeout 10 docker manifest inspect "$image:latest" > /dev/null 2>&1; then
            echo "✅ 可下载"
        else
            echo "❌ 无法获取"
        fi
    done
fi
EOF

chmod +x quick_mirror_test.sh

echo "✅ 已创建测试脚本！"
echo ""
echo "使用方法："
echo "1. 完整测试: ./docker_mirrors_test.sh"
echo "2. 快速测试: ./docker_mirrors_test.sh quick"
echo "3. 简化测试: ./quick_mirror_test.sh"
echo ""
echo "现在运行快速测试："
./quick_mirror_test.sh
```

这个脚本会：

1. **测试镜像源连通性** - 检查每个镜像源是否可以访问
2. **测试开发组件** - 检查 nginx、redis、mysql、clickhouse、starrocks 等是否可下载
3. **测试大数据组件** - 检查 spark、hadoop、kafka、flink 等大数据相关镜像
4. **不实际下载** - 只检查 manifest 信息，不下载镜像内容
5. **生成推荐配置** - 根据测试结果生成可用的镜像源配置
6. **彩色输出** - 使用颜色区分成功/失败状态

运行方式：
- `./docker_mirrors_test.sh` - 完整测试
- `./docker_mirrors_test.sh quick` - 只测试连通性
- `./quick_mirror_test.sh` - 简化版测试

这样你就能知道哪些镜像源可用，以及能下载哪些开发和大数据组件了！