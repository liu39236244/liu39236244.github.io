# HashMap 

面试必问HashMap原理，如果你还不会那很危险了
今晚8点monkey老师带来诀窍，不来听就太可惜啦
1、HashMap底层存储原理详解
2、HashMap哈希算法详解
3、哈希冲突产生的原因详解
4、HashMap底层存储数据结构详解
5、HashMap在JDK8新增的红黑树详解
6、头插入和尾插法的优缺点是什么?
7、手写实现HashMap并性能测试
8、记一次生产环境HashMap导致cpu100%的问题
上课免费地址：https://ke.qq.com/course/230866?flowToken=1032072


## 简单介绍

HashMap 底层

JDK7:数组+链表

JDK8:数组+链表+红黑树

算法决定如何存储

> 0. hashMap 简单实用

![](assets/000/01/02/100/01/01/01-1611664566628.png)


hashMap ->底层算法  hashcode（hashCode 怎么算的？md5！就是其中一中算法） 

![](assets/000/01/02/100/01/01/01-1611664741100.png)

![](assets/000/01/02/100/01/01/01-1611664859778.png)


** 但是这里 lies 是429  ，如果不取模的话 ，前面428块浪费空间，取模可以进行节省空间，优化内存空间 **


* Hash 冲突

![](assets/000/01/02/100/01/01/01-1611665146017.png)

** key 不一样，两个字母hashcode 一样，如果不解决，则会给覆盖，所以后加上链表 ** 


> 1. 下面是一个数组

![](assets/000/01/02/100/01/01/01-1611663740699.png)



> 2. 下面是一个链表结构的自定义类

![](assets/000/01/02/100/01/01/01-1611664080710.png)


* 简单说下跳表（我觉得跟mysql 底层索引 b+数有点像）

![](assets/000/01/02/100/01/01/01-1611664407418.png)


## 模拟计算hash

![](assets/000/01/02/100/01/01/01-1611665293518.png)


讲解这些值怎么存进去的

![](assets/000/01/02/100/01/01/01-1611665352569.png)


> 1.每个节点存的值？

![](assets/000/01/02/100/01/01/01-1611665425658.png)


![](assets/000/01/02/100/01/01/01-1611665644419.png)


取模之后的下标是多少就放在数组中的某个位置，如果有值，那么以链表形式存储

![](assets/000/01/02/100/01/01/01-1611665712907.png)


> 2. 取

先对key 进行hashcode ，取模 得到链表 ，然后根据hashcode 对比，挨个找值

![](assets/000/01/02/100/01/01/01-1611665782997.png)

![](assets/000/01/02/100/01/01/01-1611665876289.png)



## 源码实现


### Map 

![](assets/000/01/02/100/01/01/01-1611665985878.png)

### HashMap

![](assets/000/01/02/100/01/01/01-1611666092427.png)

![](assets/000/01/02/100/01/01/01-1611666047468.png)


> 1 put

![](assets/000/01/02/100/01/01/01-1611666196057.png)

![](assets/000/01/02/100/01/01/01-1611666257969.png)


 put 方法 ：

![](assets/000/01/02/100/01/01/01-1611666591388.png)



> 2  get 

思路

![](assets/000/01/02/100/01/01/01-1611666760608.png)



![](assets/000/01/02/100/01/01/01-1611667001196.png)


![](assets/000/01/02/100/01/01/01-1611666953597.png)


> 3 get key v 

![](assets/000/01/02/100/01/01/01-1611667252907.png)

* 测试

![](assets/000/01/02/100/01/01/01-1611667081268.png)



## 问题


hash取模 都一样，所以都在一个 数组节点的链表上

![](assets/000/01/02/100/01/01/01-1611667546167.png)


### JDK1.8 红黑树

为什么出来红黑树知道了吧？ 就是为了提升 链表的查询速度



![](assets/000/01/02/100/01/01/01-1611667658127.png)


左中右
小中大 ，

> 1 问题来了，为什么是8 的阈值？

![](assets/000/01/02/100/01/01/01-1611668502047.png)

* 红黑树

![](assets/000/01/02/100/01/01/01-1611668626748.png)

刚开始 的时候 链表效率快，红黑树则进行了左旋，维护了一个左中右的结构


* 8  阈值（2<<3 =8）  hashMap 中 1>>4 =16 

数据小于8 的话 链表性能高于红黑树， 