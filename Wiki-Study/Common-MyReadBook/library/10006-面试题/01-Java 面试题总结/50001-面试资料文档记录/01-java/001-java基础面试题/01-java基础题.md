# java基础题目



## java概述


### 1. 何为编程

```
编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过
程。
为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机
能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任
务。这种人和计算机之间交流的过程就是编程。
```


### 2. 什么是Java

```
Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继
承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编
程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。
```
### 3. 什么是面向对象编程，与面向过程编程区别

参考原文链接：

[面向对象编程及其三大特征](https://blog.csdn.net/Yusean_L/article/details/122392267)

#### 3.1 面向对象编程介绍：

面向过程与面向对象：

面向过程（Procedure Oriented 简称PO ：如C语言）：
注重过程。当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数） 。然后按照一定的顺序，执行完这些方法（每个方法看作一个过程），等方法执行完了，事情就搞定了。

面向对象（Object Oriented简称OO ：如C++，JAVA等语言）：
注重对象。当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。


面向对象的本质：
以建立模型体现出来的抽象思维过程和面向对象的方法，

#### 3.2 面向对象编程的三大特征：

![](assets/10006/01/50001/01/001/01-1658972870222.png)


##### 3.2.1 封装：

封装的概念：

封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别。将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员。

封装的优点：

把对象的私有数据和公共数据分离开，保护了私有数据，减少了可能的模块间干扰，达到降低程序复杂性、提高可控性的目的。
清楚的体现了系统之间的松散耦合关系,提高系统的独立性；
提高了程序的可复用性和可维护性，降低了程序员保持数据与操作内容的负担。

权限修饰符：

![](assets/10006/01/50001/01/001/01-1658973367378.png)


##### 3.2.2 继承：

继承是面向对象最显著的一个特性。

继承的概念：
继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。

继承的优点：
简化代码，提高复用性；
增加可维护性；

![](assets/10006/01/50001/01/001/01-1658973470855.png)


> 1 继承注意事项：

* 1 子类不继承其父类的构造方法。
    
    当使用无参数的super()时，父类的无参数构造方法就会被调用；
    当使用带有参数的super()方法时，父类的有参数构造方法就会被调用。

* 2 子类继承其父类的所有public和protected成员，但不能继承其父类的private成员。

* 3 重写父类中的方法：

    当一个子类中一个实例方法具有与其父类中的一个实例方法相同的签名（指名称、参数个数和类型）和返回值时，称子类中的方法“重写”了父类的方法。
    调用重写方法时，调用的为子类重写的方法。

* 4 隐藏父类中的方法：

    如果一个子类定义了一个静态类方法，而这个类方法与其父类的一个类方法具有相同的签名（指名称、参数格式和类型）和返回值，则称在子类中的这个类方法“隐藏”了父类中的该类方法。
    调用隐藏方法时，取决于对象是父类对象的调用还是子类对象的调用

* 5 可以在子类中通过使用关键字super()来调用父类中被重写的方法和访问父类中被隐藏的字段。


继承举例（Animal类）：

动物类（公共类，拥有公用的属性和方法）：


```java
public class Animal { 

    public String name;  
    
    public Animal(String name) {
        this.name = name;
    } 
    public void eat(){ 
        System.out.println(name+"正在吃"); 
    }
    public void sleep(){
        System.out.println(name+"正在睡");
    }
    public void introduction() { 
        System.out.println("大家好！我是"+ name); 
    } 
}

```


鸟类：

```java
public class Birld extends Animal { 

    public Birld(String name) { 
        super(name); 
    } 
    public void fly(){
        System.out.println(name+"正在飞");
    }
}


```
狗类：

```java
public class Dog extends Animal { 

    public Dog(String name) { 
        super(name); 
    } 
    public void run(){
        System.out.println(name+"正在跑");
    }
}

```



##### 3.3 多态：

相比于封装和继承，Java多态是三大特性中相对更难理解的一个，封装和继承最后归结于多态。

> 1 多态的两种分类：

    重载式多态（方法重载），也叫编译时多态。也就是说这种多态再编译时已经确定好了。重载大家都知道，方法名相同而参数列表不同的一组方法就是重载。在调用这种重载的方法时，通过传入不同的参数最后得到不同的结果。

    重写式多态（方法重写），也叫运行时多态。这种多态通过动态绑定（dynamic binding）技术来实现，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。也就是说，只有程序运行起来，你才知道调用的是哪个子类的方法。

    这种多态通过函数的重写以及向上转型来实现，我们下面代码中的例子就是一个重写式多态。

> 2 向上转型：

Person（父类）：

```java

public class Person {

    private int money=100;
    
    public void say(){
    System.out.println("我是人类");
    }

}


```


Student（子类）：

```java
public class Student extends Person {

    private int money=1;

    public void say(){
        System.out.println("我是学生");
    }
    
}

```
Application：

```java
public class Application {
    public static void main(String[] args) {
    
        Student student=new Student();
       
        Person p1=new Person();
//多态性的体现
        /*
          向上转型
          从子到父
          父类的引用指向子类的对象
        */
        Person p2=new Student();

//成员变量不具有多态性：编译看左边，执行看左边
        System.out.println(p1.getMoney());
        System.out.println(p2.getMoney());
//成员方法具有多态性：编译看左边，执行看右边
        p1.say();//执行父类say方法
        p2.say();//执行子类say方法
    }
}

```

p2是person的引用，指向了子类Student的对象

```
成员变量不具有多态性

成员方法具有多态性

```
故可得到执行结果：

    100
    100
    我是人类
    我是学生


> 3 为什么要发生向上转型？


减少重复代码，使代码变得简洁。
提高系统扩展性。
用于参数统一化,假设父类有n个子类，方法要接受子类的实例，如果没有向上转型，就需要定义n个方法接收不同的对象。


向下转型：

Person（父类）：

```java
public class Person {

    public void run (){System.out.println("run");}

}
```

Student（子类）：

```java

public class Student extends Person{

    public void go (){System.out.println("go");}

}
```

Application：

```java
public class Application {
    public static void main(String[] args) {
        /*
          向上转型
          从子到父
          父类的引用指向子类的对象
        */
        Person obj=new Student();   //高<--低
        obj.run();//此处的run为Student继承person的run();
//      obj.go(); //编译报错 父类中无此方法

//--------------------------------------------------------------------------
// student 将这个对象转换为Student类型，我们就可以使用Student的方法了。
        /*
         向下转型
         从父到子
         父亲引用转为子类对象
        */
        Student obj1=(Student)obj;   //低<--高
        obj1.go();
//        即为强行转换
//        ((Student)obj).go();
//--------------------------------------------------------------------------
        Student obj2=new Student();
        Person person=obj2;                //高<--低 自动转换
//      person.go();  //低转高（子类转换为父类）丢失了子类的方法go();
    }
}

```
结果：

    run
    go

为什么要发生向下转型？

    当父类需要调用子类的扩充方法时，需要向下转型。
    一般不操作向下转型，有安全隐患(比如子类实际new 的并不是含有方法的子类类型)


### 4. jdk1.5之后的三大版本


#### 1  Java SE（J2SE，Java 2 Platform Standard Edition，标准版）

    Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java
    应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。


![](assets/10006/01/50001/01/001/01-1658977632414.png)


* Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）

    Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应
    用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，
    可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应
    用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE

![](assets/10006/01/50001/01/001/01-1658977641694.png)

* Java ME（J2ME，Java 2 Platform Micro Edition，微型版）
  
    Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和
    打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安
    全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java
    ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。


### 5. Jdk和Jre和JVM的区别


看Java官方的图片，Jdk中包括了Jre，Jre中包括了JVM,[官方地址](https://www.oracle.com/java/technologies/platform-glance.html)

* JDK ：Jdk还包括了一些Jre之外的东西 ，就是这些东西帮我们编译Java代码的， 还有就是监控Jvm
    的一些工具 Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也
    包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，
    打包工具(jar.exe)等

* JRE ：Jre大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库 Java
    Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang
    包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线
    程、异常处理类等，系统缺省加载这个包

* 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。
    
    Jvm：在倒数第二层 由他可以在（最后一层的）各种平台上运行 Java Virtual Machine是Java虚拟
    机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。



### 6. 什么是跨平台性？原理是什么

所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。
实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟
机，该系统就可以运行java程序

#### 6.1 具有跨平台性的语言还知道哪些吗，非跨平台性的语言呢，为什么他们不能跨平台呢？

##### 6.1.1 什么是跨平台性？原理是什么


java说自己跨平台，是因为它和C相比，编译出来的二进制文件可以在其他任何安装了Java运行环境的平台上运行，注意，没安装的话那就歇菜。而C，编译出来的东西一般只能在一类操作系统上运行，换了地儿就不行了，但是运行时不需要额外安装任何运行环境，然而你依然可以为指定的cpu、操作系统单独编译一份。

C#，python，php，js等等全都可以一份代码在多种平台上直接运行。不过都需要相应的运行环境。

java C# 是解释型的语言

C/C++ 是编译型的语言

有些语言如JavaScript，Python等，他们是解释执行的，不存在编译过程，所以也能跨平台，前提是必须要有一个对应的解释器，PHP好像也是解释性的。


![](assets/10006/01/50001/01/001/01-1658978022541.png)




### 7. Java语言有哪些特点

```
简单易学（Java语言的语法与C语言和C++语言很接近）
面向对象（封装，继承，多态）
平台无关性（Java虚拟机实现平台无关性）
支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）
支持多线程（多线程机制使应用程序在同一时间并行执行多项任）
健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）
安全性好
```


### 8. 什么是字节码？采用字节码的最大好处是什么

#### 8.1 字节码：

Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任
何特定的处理器，只面向虚拟机。

#### 8.2 采用字节码的好处：

Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留
了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定
的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。


##### 8.2.1 先看下java中的编译器和解释器：

    Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机
    器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能
    够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚
    拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟
    机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变
    成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻
    译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释
    并存的解释。
    
    Java源代码---->编译器---->jvm可执行的Java字节码(即虚拟指令)---->jvm---->jvm中解释器----->机
    器可执行的二进制机器码---->程序运行。


### 9. 什么是Java程序的主类？应用程序和小程序的主类有何不同？

    一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()
    方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序
    的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口
    点。

### 10. Java应用程序与小程序之间有那些差别？

    简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏
    览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。

### Java和C++的区别
 
* 我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！

    都是面向对象的语言，都支持封装、继承和多态
    Java不提供指针来直接访问内存，程序内存更加安全
    Java的类是单继承的，C++支持多类继承；虽然Java的类不可以多继承，但是接口可以多重继承。
    Java有自动内存管理机制，不需要程序员手动释放无用内存


### Oracle JDK 和 OpenJDK 的对比

#### 1答案简述

  1. Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；
  2. OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全
  开源的；
  3. Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的
  类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过
  了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃
  的问题，但是，只需切换到Oracle JDK就可以解决问题；
  4. 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；
  5. Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来
  获取最新版本；
  6. Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。


#### 2 其他参考说明

原文地址:[openjdk与Oraclejdk的区别](https://www.jb51.net/article/193604.htm)

在2006年11月13日的JavaOne大会上，Sun公司（当时还没被收购）宣布计划要把Java开源，在随后的一年多时间内，它陆续地将JDK的各个部分在GPL v2（GNU 

General Public License v2）协议下公开了源码，并建立了OpenJDK组织对这些源码进行独立管理。除了极少量的产权代码（Encumbered Code，这部分代码所有权不

属于Sun公司，Sun本身也无权进行开源处理）外，OpenJDK几乎拥有了当时SunJDK 的全部代码。

OpenJDK的质量主管曾经表示在JDK 7中，SunJDK和OpenJDK除了代码文件头的版权注释之外，代码几乎是完全一样的，所以OpenJDK 7与SunJDK 7本质上就是同一套代码库出来的产品。


##### 2.1 区别

###### 2.1.1 授权协议不同

OpenJDK 采用GPL V2协议放出，而OracleJDK则采用JRL放出。两者协议虽然都是开放源代码的，但是在使用上的不同在于GPL V2允许在商业上使用，而JRL只允许个人研究使用。

OpenJDK不包含OracleJDK中的部分产权代码

由于OracleJDK中的部分代码的产权也不是归Oracle所有的，所以这部分代码就没开源到OpenJDK中。但是很多“好心”的开源爱好者在OpenJDK中实现了相同的功能，并将源代码开源到OpenJDK中。比如说字体栅格化引擎，使用Free Type代替。

###### 2.1.2 不能使用Java商标

在Sun被Oracle收购以后，Java这个商标就归Oracle所有了。不仅OpenJDK不能使用java商标，J2EE这个曾经Sun的亲儿子命运也同样坎坷，已经被Oracle无情抛弃，同样
不能在使用Java商标。


但是随着JDK版本的不断发布，Oracle失去了维护OpenJDK的耐心，因为不赚钱啊。RedHat从Oracle手上接过OpenJDK的管理权利和维护职责。

2019年3月20日，JDK 12发布，只包含8个JEP，其中主要有Switch表达式、Java微测试套件（JMH）等新功能，最引人注目的特性无疑是加入了由RedHat领导开发的

Shen-andoah垃圾收集器。Shenandoah作为首个由非Oracle开发的垃圾收集器，其目标又与Oracle在JDK 11中发布的ZGC几乎完全一致，两者天生就存在竞争。Oracle

马上用实际行动抵制了这个新收集器，在JDK 11发布时才说应尽可能保证OracleJDK和OpenJDK的兼容一致，转眼就在OracleJDK 12里把Shenandoah的代码通过条件编

译强行剔除掉，使其成为历史上唯一进入了OpenJDK发布清单，但在OracleJDK中无法使用的功能。

所以对于高版本的OpenJDK和OracleJDK之间，也存在OpenJDK中有的功能，但是OracleJDK中不包含的。

总的来说，对于普通开发，使用OpenJDK和OracleJDK并没有太大差别，两者的差别更体现在商业考量上面。

###### 2.1.3  openjdk源代码不完整


    这个很容易想到，在采用GPL协议的OpenJDK中，SUN JDK的一部分源代码因为产权的问题无法开放给OpenJDK使用，其中最主要的部份就是JMX中的可选元件SNMP部份的代码。因此这些不能开放的源代码 将它作成plug，以供OpenJDK编译时使用，你也可以选择不要使用plug。而Icedtea则为这些不完整的部分开发了相同功能的源代码 (OpenJDK6)，促使OpenJDK更加完整。


## java基础语法

### 1 数据类型

#### 1.1 java 有哪些数据类型

定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同
大小的内存空间。

#### 1.2 数据类型图示

![](assets/10006/01/50001/01/001/01-1660011925883.png)

* 注意 E38 的含义

```
    这是科学记数法

    E表示10的次方

    E38 表示10的38次方

    -3.402823E38的E=-3.402823×10^38

```

##### 1.3 float 精度解释

[原文地址float的精度和取值范围](https://blog.csdn.net/albertsh/article/details/92385277)

#### 1.3   switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String上

    在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中
    引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），
    但是长整型（long）在目前所有的版本中都是不可以的。


#### 1.4 用最有效率的方法计算 2 乘以 8

    2 << 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。 

也就是 << 3 代表  ： * 2的三次方， 100 << 3 就是 100 * （2 的三次方）= 100 * 8 = 800


#### 1.5  Math.round(11.5) 等于多少？Math.round(-11.5)等于多少


    Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数
    上加 0.5 然后进行下取整。


##### 1.5.1 博客详解

[原文地址 详解Math.round函数](https://blog.csdn.net/weixin_39428938/article/details/105045233)

案例：

```java
public static void main(String[] args) {
        System.out.println("小数点后第一位=5");
        System.out.println("正数：Math.round(11.5)=" + Math.round(11.5));//12
        System.out.println("负数：Math.round(-11.5)=" + Math.round(-11.5));//-11
        System.out.println();
        System.out.println("小数点后第一位<5");
        System.out.println("正数：Math.round(11.46)=" + Math.round(11.46));//11
        System.out.println("负数：Math.round(-11.46)=" + Math.round(-11.46));//-11
        System.out.println();
        System.out.println("小数点后第一位>5");
        System.out.println("正数：Math.round(11.68)=" + Math.round(11.68));//12
        System.out.println("负数：Math.round(-11.68)=" + Math.round(-11.68));//-12
    }

```

* math.round 既不是四舍五入也不是四舍六入五成双， 而是加0.5以后， 在使用floor 向下取整

源码如下：

```java
 public static long round(double a) {
        if (a != 0x1.fffffffffffffp-2) // greatest double value less than 0.5
            return (long)floor(a + 0.5d);
        else
            return 0;
    }

```

![](assets/10006/01/50001/01/001/01-1660013744666.png)



```
Math类中提供了三个与取整有关的方法：ceil,floor,round,这些方法的作用于它们的英文名称的含义相对应，例如：ceil的英文意义是天花板，该方法就表示向上取整，Math.ceil（11.3）的结果为12，Math.ceil(-11.6)的结果为-11；floor的英文是地板，该方法就表示向下取整，

Math.floor(11.6)的结果是11，Math.floor(-11.4)的结果-12；
最难掌握的是round方法，他表示“四舍五入”，算法为Math.floor(x+0.5),即将原来的数字加上0.5后再向下取整，所以，Math.round(11.5)的结果是12，Math.round(-11.5)的结果为-11.
```


#### 1.6 float f=3.4;是否正确

    不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（downcasting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float
    f =3.4F; (大写F 小写f 都可以)


而且编译也会提示错误

![](assets/10006/01/50001/01/001/01-1660014170411.png)

##### 1.6.1 不同进制初始化表达


    float类型初始化方法：floatscore=78.5f;

    1、java基本数据类型

    Java定义了8个简单的数据类型：字节型（byte），短整型（short），整型（int），长整型（long），字符型（char），浮点型（float），双精度型（double），布尔型（boolean）
    2、默认值

    除了boolean默认false，char--〉/u0000，其他的都为0
    3、常量
    十六进制整型常量：以十六进制表示时，需以0x或0X开头，如0xff,0X9A。
    八进制整型常量：八进制必须以0开头，如0123，034。
    长整型：长整型必须以L作结尾，如9L,342L。
    浮点数常量：由于小数常量的默认类型是double型，所以float类型的后面一定要加f(F)。同样带小数的变量默认为double类型

#### 1.7 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗

    前者编译也报错；

    对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换
    类型才能赋值给 short 型。
    而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强
    制类型转换。


### 2 编码

#### 2.1 Java语言采用何种编码方案？有何特点？

    Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因
    此在任何的语言，平台，程序都可以放心的使用。




### 3 注释

    定义：用于解释说明程序的文字
    分类
    单行注释
    格式： // 注释文字
    多行注释
    格式： /* 注释文字 */
    文档注释
    格式：/** 注释文字 */
    
    作用
    在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调
    试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的
    执行结果产生任何影响。
    注意事项：多行和文档注释都不能嵌套使用。

### 4 访问修饰符

 访问修饰符 public,private,protected,以及不写（默认）时的区别

![](assets/10006/01/50001/01/001/01-1660014661131.png)


### 5 内部类一些知识


[原文链接：java内部类最全详解](https://blog.csdn.net/weixin_46972127/article/details/123609366)

    1、可以在方法中定义内部类
    2、方法中的内部类在jdk1.8版本之前如果要访问方法的参数和局部变量需要使用final修饰变量和参数。
    3、方法的内部类作为了解，其实上内部类的课程没什么逻辑，你记住就好了。


### 6 运算符


&和&&的区别

&运算符有两种用法：(1)按位与；(2)逻辑与。

&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端
的布尔值都是true 整个表达式的值才是 true。&&之所以称为短路运算，是因为如果&&左边的表
达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。

注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。





【java书签%%】

### 7 关键字

#### 7.1 Java 有没有 goto

goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。


#### 7.2  final 有什么用？

    用于修饰类、属性和方法；
    被final修饰的类不可以被继承
    被final修饰的方法不可以被重写
    被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，比如  final int i=5; i 不能再被赋值，但是final Student stu=new Student(); 虽然 stu 不可以指向其他Student 对象，但是stu对应在堆上的学生类的一些自定义属性是可以被修改的
    引用指向的内容是可以改变的

#### 7.3  final finally finalize区别

    final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、
    修饰变量表 示该变量是一个常量不能被重新赋值。
    finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法
    finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代
    码。
    finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾
    回收器来调 用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一
    个对象是否可回收的 最后判断。


#### 7.4 this关键字的用法

this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。

this的用法在java中大体可以分为3种：

#####  1.普通的直接引用，this相当于是指向当前对象本身。
    
    
##### 2.形参与成员名字重名，用this来区分：

```java
public Person(String name, int age) {
    this.name = name;
    this.age = age;
}

```
##### 3.引用本类的构造函数

```java


class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name) {
        this.name = name;
    }

    public Person(String name, int age) {
        this(name);
        this.age = age;
    }
}
```
#### 7.5 super关键字的用法

super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父
类。

super也有三种用法：

> 1.普通的直接引用
        与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。
    
> 2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分

```java

class Person {
    protected String name;

    public Person(String name) {
        this.name = name;
    }
}

class Student extends Person {
    private String name;

    public Student(String name, String name1) {
        super(name);
        this.name = name1;
    }

    public void getInfo() {
        System.out.println(this.name); //Child
        System.out.println(super.name); //Father
    }
}

public class Test {
    public static void main(String[] args) {
        Student s1 = new Student("Father", "Child");
        s1.getInfo();
    }
}



```

> 3.引用父类构造函数


super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。

this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。



#### 7.6 this与super的区别


    super:它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函
    数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）
    
    this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；
    
    super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其
    它构造方法。

    super()和this()均需放在构造方法内第一行。

    尽管可以用this调用一个构造器，但却不能调用两个。
    
    this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构
    造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的
    意义，编译器也不会通过。
    
    this()和super()都指的是**对象**，所以，均不可以在static环境中使用。包括：static变量,static方
    法，static语句块。
    
    从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。

#### 7.7  static存在的主要意义

> 1 static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能
使用属性和调用方法！

> 2static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。 
    
    static块可以置于类中的任何地方，
    类中可以有多个static块。
    在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。

>3 为什么说static块可以用来优化程序性能，
    
    是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。



#### 7.8  static 的独特之处


> 1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任

```
    何一个实例对象，而是被类的实例对象所共享。
    怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大
    伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享
    的，不像成员变量是自个的【自个指的是这个类的单个实例对象】,就是每一次new XXX(); 的对象就是指的每个自个;

```    
> 2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载

    并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。

如下代码：

```
class A{
    private  String name ;
    private  String address;
    public static int a=1;

    public void setName(String name) {
        this.name = name;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public static void main(String[] args) {
        System.out.println(A.a);// 1
        A.a = 2;
        System.out.println(A.a);// 2

    }
}

```
> 3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！

> 4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没
有创建对象，也可以去访问。

#### 7.9 static应用场景

因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。

因此比较常见的static应用场景有：

`1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部
类】 5、静态导包`

#### 7.10 static注意事项

```

    1、静态只能访问静态。
    2、非静态既可以访问非静态的，也可以访问静态的

```

### 8 流程控制语句

#### 8.1  break ,continue ,return 的区别及作用

```
    break 跳出总上一层循环，不再执行循环(结束当前的循环体)
    continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)
    return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)

```

#### 8.2 在 Java 中，如何跳出当前的多重嵌套循环

在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码
中使用带有标号的break 语句，即可跳出外层循环。例如

```java
  public static void main(String[] args) {
        ok:
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                System.out.println("i=" + i + ",j=" + j);
                if (j == 5) {
                    break ok;
                }
            }
        }
        // i=0,j=0
        // i=0,j=1
        // i=0,j=2
        // i=0,j=3
        // i=0,j=4
        // i=0,j=5
        // 跳出循环
        System.out.println("跳出循环");
    }

```



##  面向对象


### 1 面向过程：

优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、
嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。

缺点：没有面向对象易维护、易复用、易扩展

面向对象：
优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出
低耦合的系统，使系统更加灵活、更加易于维护

缺点：性能比面向过程低

面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。

面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需
要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就
可以了。

面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。

### 2 面向对象


面向对象的特征有哪些方面

面向对象的特征主要有以下几个方面**：

```
抽象：
抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽
象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

封装:
把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界
访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个
类也没有什么意义了。

继承:
是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功
能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前
的代码。

多态：
父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。
在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖
接口中同一方法）。

关于继承如下 3 点请记住：

1. 子类拥有父类非 private 的属性和方法。

2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。（以后介绍）。


```
### 3 什么是多态机制？Java语言是如何实现多态的？


> 1 主要用与封装框架，方法上可以定义运行时不确定的类

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程
时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用
变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运
行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现
上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的
具体代码，让程序可以选择多个运行状态，这就是多态性。

> 2 主要用与同名函数的不同参数

多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参
数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而
运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。



多态的实现


Java实现多态有三个必要条件：继承、重写、向上转型。
继承：在多态中必须存在有继承关系的子类和父类。
重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用
父类的方法和子类的方法。



只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执
行不同的行为。
对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不
是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆
盖的方法。


### 4 面向对象五大基本原则是什么（可选）


```
1 单一职责原则SRP(Single Responsibility Principle)

类的功能要单一，不能包罗万象，跟杂货铺似的。

2 开放封闭原则OCP(Open－Close Principle)

一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万
个不乐意。


3 里式替换原则LSP(the Liskov Substitution Principle LSP)


子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~


4 依赖倒置原则DIP(the Dependency Inversion Principle DIP)

高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实
现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中
国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村
的。


5 接口分离原则ISP(the Interface Segregation Principle ISP)

设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电
话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。
```
### 5 类与接口

#### 5.1 抽象类和接口的对比


* 抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。
* 从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规
范。

> 1 相同点 

* 1 接口和抽象类都不能实例化
* 2 都位于继承的顶端，用于被其他实现或继承
* 3 都包含抽象方法，其子类都必须覆写这些抽象方法

> 2 不同点

![](assets/10006/01/50001/01/001/01-1673063462684.png)


备注：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。

现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。


```
接口和抽象类各有优缺点

在接口和抽象类的选择上，必须遵守这样一个原则：

1 行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象
类。

2 选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。
```


##### 5.1.1 扩展

JDK1.8之前的接口的定义和限制

```
接口不能用于实例化对象。
接口没有构造方法。
接口中所有的方法必须是抽象方法。
接口不能包含成员变量，除了 static 和 final 变量。
接口不是被类继承了，而是要被类实现。
接口支持多继承。

```


JDK1.8接口支持静态方法和默认方法
默认方法主要优势：

1、提供了一种扩展接口的方法，而不破坏现有代码。



`如果一个已经投入使用的接口需要扩展一个新的方法，在JDK8以前，我们必须再该接口的所有实现类中都添加该方法的实现，否则编译会出错。如果实现类数量很少且我们有修改的权限，可能工作量会少，但是如果实现类很多或者我们没有修改代码的权限，这样的话就很难解决了。而默认方法提供了一个实现，当没有显式提供时就默认采用这个实现，这样新添加的接口就不会破坏现有的代码。`

2、默认方法另一个优势是该方法是可选的，子类可以根据不同的需求而且经override或者采用默认实现。

总结:

```
总结：
1、接口默认方法、静态方法可以有多个。

2、默认方法通过实例调用，静态方法通过接口名调用。

3、default默认方法关键字只能用在接口中。

4、默认方法可以被继承，如果继承了多个接口，多个接口都定义了多个同样的默认方法，实现类需要重写默认方法不然会报错。

5、静态方法不能被继承及覆盖，所以只被具体所在的接口调用。

```

##### 5.1.2 代码案例

原文链接：https://blog.csdn.net/wxd_1024/article/details/88853899

```java
public interface InterfaceJDK8 {
 
	/*接口的普通抽象方法*/
	public void commonMethod(String str);
 
	/*jdk1.8 默认方法:
	允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性，
        默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有要求实现，
	相反，接口提供了一个默认实现，这样所有的接口实现者将会默认继承他
       （如果有必要的话，可以覆盖这个默认实现）。
	接口的默认方法：得到接口的实现类对象，直接用对象的引用.方法名。默认方法可以被实现类覆盖。
	*/
	default public void defaultMethod(String str){
		System.out.println("InterfaceJDK8:" + str);
	}
 
 
	/*jdk1.8 静态方法：
	允许在已有的接口中添加静态方法，接口的静态方法属于接口本身，不被继承，也不需要提供方法的实现。
        */
	public static void staticMethod(String str){
		System.out.println("InterfaceJDK8:" + str);
	}
 
}

```

> 1 子类1 
>
```java
public class InterfaceJDK8Impl implements InterfaceJDK8 {
	@Override
	public void commonMethod(String str) {
		System.out.println("我是通通方法");
	}
 
 
 
 
	public static void main(String[] args){
                //静态方法 接口.方法 调用  （不被继承，不被实现）
		InterfaceJDK8.staticMethod("我是静态方法");
 
                InterfaceJDK8Impl interfaceJDK8Impl = new InterfaceJDK8Impl();
                //默认方法 实例.方法名 调用 （被继承，可以重写覆盖默认实现，也可以不重写）
		interfaceJDK8Impl.defauleMethod("我是默认方法");
 
	}
}
 
 
// InterfaceJDK8 :我是静态方法
// InterfaceJDK8 :我是默认方法


```

> 2 子类2
>
```java

public class InterfaceJDK8Impl implements InterfaceJDK8 {
	@Override
	public void commonMethod(String str) {
		System.out.println("InterfaceJDK8Impl :我是通通方法");
	}
 
	@Override
	public void defauleMethod(String str) {
		System.out.println("InterfaceJDK8Impl :" + str);
	}
 
	public static void main(String[] args){
		InterfaceJDK8.staticMethod("我是静态方法");
 
		InterfaceJDK8Impl interfaceJDK8Impl = new InterfaceJDK8Impl();
		interfaceJDK8Impl.defauleMethod("我是默认方法");
 
	}
}
 
 
// InterfaceJDK8 :我是静态方法
// InterfaceJDK8Impl :我是默认方法

```


接口默认方法的”类优先”原则
若一个接口中定义了一个默认方法，而另外一个父类或接口中 又定义了一个同名的方法时  选择父类中的方法。如果一个父类提供了具体的实现，那么 接口中具有相同名称和参数的默认方法会被忽略。（我理解的就是如果父类或者上级有了具体实现，那么本类的默认方法会失效）

接口冲突：如果一个父接口提供一个默认方法，而另一个接 口也提供了一个具有相同名称和参数列表的方法（不管方法 是否是默认方法），那么必须覆盖该方法来解决冲突


#### 5.2 普通类和抽象类有哪些区别？


普通类不能包含抽象方法，抽象类可以包含抽象方法。

抽象类不能直接实例化，普通类可以直接实例化。


#### 5.3 抽象类能使用 final 修饰吗？

不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生
矛盾，所以 final 不能修饰抽象类


#### 5.4 创建一个对象用什么关键字？对象实例与对象引用有何不同？

new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放
在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气
球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）


#### 5.5 成员变量与局部变量的区别有哪些

```

变量：
在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存
中的一小块区域

成员变量：方法外部，类内部定义的变量
局部变量：类的方法中的变量。
成员变量和局部变量的区别

作用域
成员变量：针对整个类有效。
局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)

存储位置
成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。
局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语
句结束后，就自动释放。

生命周期
成员变量：随着对象的创建而存在，随着对象的消失而消失
局部变量：当方法调用完，或者语句结束后，就自动释放。

初始值
成员变量：有默认初始值。
局部变量：没有默认初始值，使用前必须赋值。
```
#### 5.6 新增


## IO流


## 反射

## 常用API


