集合框架（对象数组的概述和使用）结合类能存储任意对象，长度是可以改变的，随着元素的增加而增加，元素的减少而减少数组和集合的区别1、数组既可以存储基本数据类型，也可以存储引用数据类型，但集合中只能存储引用数据类型，如要存储基本数据类型，在存储过程中会自动装箱变成对象。2、数组元素的固定的，不能自动增长，而集合长度是可变的，可以根据元素的增加而增长                              Collection       List                                            Set(有序，存取数据有序，索引，可重复)   （无序，存取顺序不一致，无索引，不可以存储重复数据）ArrayList  LinkedList Vector(数组)     HashSet（哈希表）  TreeSet（二叉树）--------------------------------------------------------------------------Collection（Util）Collection collection = new ArrayList();boolean flg = collection.add(Object o);c.clear()c.size()c.contain(对象);集合转数组遍历Object[] arr = coll.toArray();//要对Object进行强制类型转换boolean flg = c.addAll(collection c1); 把c1中的每一个元素添加到c中boolean flg = c.removeAll(collection c1); 删除的是由交集的部分boolean flg = c.containsAll(collection c1);判断调用的集合是否包含传入的数据boolean flg = c.returnAll(collection c1);去交集，如果调用的集合改变，返回true，如果调用集合不变就返回false--------------------------------------------------------------------------集合的迭代器遍历Iterator it = collection.iterator();while(it.hasNext()){ Object o = it.next();//调用一次，指针向后移动一次}为什么要将方法抽取到接口中new迭代器对集合遍历，每一个集合内部的存储结构不同，每个集合存取都不同，如果每个都写在其中，过于臃肿好处1、声明了规则，只能使用hasNext()和next()2、代码底层内部实现，使用者无需关系如何实现--------------------------------------------------------------------------List集合的特有功能概述和测试List<T> list = new ArrayList<T>();Object obj = list.remove(key);//按照序列号返回删除的时候不能自动装箱，只能当做key来使用Object obj = list.get(key);list.set(key,value);--------------------------------------------------------------------------并发修改异常产生的原因以及解决方案（迭代器运行过程中，不能够修改）ConcurrentModificationException并发修改异常1、采用迭代器修改元素的特有功能 采用ListIterator lit = list.listIterator(); 就可以使用add()方法了2、采用遍历元素的方法ListIterator方法next()  hasNext()preivous() hasPrevious()//直接反向遍历 必须让迭代器指针放置在最后一个元素--------------------------------------------------------------------------Vector类的特有功能Vector v = new Vector()Enumeration e =v.elements();while(en.hasMoreElement()){}--------------------------------------------------------------------------数组 查询、修改快，增删慢（ArrayList）线程不安全，效率高数组 查询、修改快，增删慢（Vector）线程安全，效率低Vector相对于ArrayList查询慢（线程安全）Vector相对于LinkedList增删慢（数组结构）链表 查询、修改慢，增删快（LinkedList）线程不安全 效率高Vector和ArrayList区别Vector是线程安全的，效率低ArrayList是线程不安全的，效率高其中，他们的底层结构都是数组ArrayList和LinkedList都是线程不安全的查询多用ArrayList增删多用 LinkedList都多使用ArrayList--------------------------------------------------------------------------去除ArrayList中重复值思路是创建新的集合方式public static ArrayList getSingle(ArrayList list){ ArrayList newList = new ArrayList<>(); Iterator it = list.iterator();  while(it.hasNext()){	Object obj = it.next();      if(newList.contains(obj)){	}else{        newList.add(obj);      }   } return newList;}------------------------------------------------------如果要去除自定义对象remove方法和contains方法底层都是用的equals方法，所以对于自定义对象要使用重写equals方法实现该效果-----------------------------------------------------------------LinkedList的特有功能addFirst(E e)  addLast(E e)getFirst()   getLast()removeFirst() removeLast()get(int index) 这里的index和数组一致-------------------------------------------------栈和队列的区别栈是先进后出，队列是先进先出利用LinkedList模拟栈public class Stack{private LinkedList list = new LinkedList();//模拟进栈方法public void in(Object obj){   list.addLast(obj);}public Object out(Object obj){   //模拟出栈  return list.removeLast();}public boolean isEmpty(){	return list.isEmpty(); }}--------------------------------------------------泛型的优势：<必须存储引用数据类型，并且保证前后数据类型一致>如果不使用泛型，当强转至某一个对象时，会出现ClassCastException优势：提高了安全性，省去强转的麻烦，最好不要用Obejct1 自定义类加泛型   public class A<E>{}  可以指定方法中某些必须调用的类型2 自定义泛型方法的概述   public void method(E e){}在创建对象使用中，自动使用泛型的类型，方法泛型要和类的泛型一致  如方法自带自己的泛型 public<T> void show(T t){}则可以使用自定义的对象3 自定义静态方法无法使用类泛型，因为在静态方法中，加载过程中可能还没有对象   静态方法只能使用自己的泛型public static<W> void show(W w);自定义泛型接口interface Inter<T>{ public void show(T t);}class Demo implements Inter<String 直接指定类>{}class Demo<T> implements Inter<T>{}------------------------------------------------------------------泛型高级之通配符泛型通配符<?> 可以替代任意的类型，替代Object不会报错? extends E 向下限定 E极其子类 使用E类型或者E的子类型? super E 向上限定 E极其父类-----------------------------------------------------------------ArrayList存储字符串字符串并遍历泛型ArrayList<String> arrayList = new ArrayList<String>();list.add("");Iterator<String> it = arrayList.iterator();while(it.hasNext()){ it.next();//只能调用一次，否则会出现指针后移一位}-------------------------------------------------------------------三种迭代能否删除1、普通for循环 可以删除，但是索引要-- list.remove(i--)2、迭代器，可以删除，但是必须使用自身的remove()方法，否则会出现并发异常3、增强for循环不能删除------------------------------------------------------------------JDK1.5 静态导入 导入类中的静态方法import static 包名，类名，方法 但是会和本类的静态方法出现冲突JDK1.5 int...arr = int[] arr 并且其可以自动将参数变成数组，该参数必须放在参数列表的最后一个位置（int x,int...x）-------------------------------------------------------------------Arrays.asList(T...a) 返回一个受指定数组支持的固定大小的List（这个List不支持增加，删除，其他都可以）但是使用基本数据类型的数据，放置在list中打印出地是地址因为list中只能存放引用数据类型，所以默认将基本数据类型的数组当做引用，并打印地址修改方法就是将基本数据类型改成引用数据类型集合转数组使用泛型Integer[] array = list.toArray(new Interger[size]);当集合转换数组时，数组的长度如果是小于等于集合size（）时，转换后的数组长度等于集合的length，如果数组的长度大于size，则分配的数组长度和指定的长度一致-------------------------------------------------------------------ArrayList 用增强for遍历,简化遍历，依赖的是迭代器for(Person person :list){}ArrayList嵌套ArrayListArrayList<ArrayList<Object>> lists  = new ArrayList<ArrayList<Objext>>();


