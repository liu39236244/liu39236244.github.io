# Volatile


[原地址](http://www.jayh.club/#/10.并发多线程/01.反制面试官-14张原理图-再也不怕被问volatile!)

## 记录

### java 内存模型思维导图


![](assets/001/11/10/01-1638945495035.png)


### java内存模型有以下规则

Java内存模型的几个规范：

1.所有变量存储在主内存

2.主内存是虚拟机内存的一部分

3.每条线程有自己的工作内存

4.线程的工作内存保存变量的主内存副本

5.线程对变量的操作必须在工作内存中进行

6.不同线程之间无法直接访问对方工作内存中的变量

7.线程间变量值的传递均需要通过主内存来完成


```
由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：
```

![](assets/001/11/10/01-1638946326412.png)



### Java内存模型的三大特性

```
可见性（当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改）
原子性（一个操作或一系列操作是不可分割的，要么同时成功，要么同时失败）
有序性（变量赋值操作的顺序与程序代码中的执行顺序一致）
关于有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。


```



### volatile


//volatile 修饰的关键字，是为了增加多个线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知

class ShareData {
    //volatile 修饰的关键字，是为了增加多个线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知
    volatile int number = 0;

    public void setNumberTo100() {
        this.number = 100;
    }
}


### 加了volatile 其他线程为何能感知到？

其实这里就是用到了“窥探（snooping）”协议。在说“窥探（snooping）”协议之前，首先谈谈缓存一致性的问题。



> 1 缓存一致性

当多个CPU持有的缓存都来自同一个主内存的拷贝，当有其他CPU偷偷改了这个主内存数据后，其他CPU并不知道，那拷贝的内存将会和主内存不一致，这就是缓存不一致。那我们如何来保证缓存一致呢？这里就需要操作系统来共同制定一个同步规则来保证，而这个规则就有MESI协议。

如下图所示，CPU2 偷偷将num修改为2，内存中num也被修改为2，但是CPU1和CPU3并不知道num值变了。

![](assets/001/11/10/01-1638946962197.png)


> 2 MESI

当CPU写数据时，如果发现操作的变量是共享变量，即在其它CPU中也存在该变量的副本，系统会发出信号通知其它CPU将该内存变量的缓存行设置为无效。如下图所示，CPU1和CPU3 中num=1已经失效了。


![](assets/001/11/10/01-1638947144457.png)


当其它CPU读取这个变量的时，发现自己缓存该变量的缓存行是无效的，那么它就会从内存中重新读取。

如下图所示，CPU1和CPU3发现缓存的num值失效了，就重新从内存读取，num值更新为2。

![](assets/001/11/10/01-1638947150500.png)



> 3 总线嗅探

那其他CPU是怎么知道要将缓存更新为失效的呢？这里是用到了总线嗅探技术。

每个CPU不断嗅探总线上传播的数据来检查自己缓存值是否过期了，如果处理器发现自己的缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改操作的时候，会重新从内存中把数据读取到处理器缓存中。


> 4 总线风暴

总线嗅探技术有哪些缺点？

由于MESI缓存一致性协议，需要不断对主线进行内存嗅探，大量的交互会导致总线带宽达到峰值。因此不要滥用volatile，可以用锁来替代，看场景啦~

###    能演示下volatile为什么不保证原子性吗？

原子性：一个操作或一系列操作是不可分割的，要么同时成功，要么同时失败。

这个定义和volatile啥关系呀，完全不能理解呀？Show me the code!

考虑一下这种场景:

当20个线程同时给number自增1，执行1000次以后，number的值为多少呢？

在单线程的场景，答案是20000，如果是多线程的场景下呢？答案是可能是20000，但很多情况下都是小于20000。




### 怎么保证输出结果是20000呢？

#### synchronized同步代码块


我们可以通过使用synchronized同步代码块来保证原子性。从而使结果等于20000

public synchronized static void increase() {
   number++;
}


但是使用synchronized太重了，会造成阻塞，只有一个线程能进入到这个方法。我们可以使用Java并发包（JUC）中的AtomicInterger工具包。


#### AtomicInterger原子性操作

我们来看看AtomicInterger原子自增的方法getAndIncrement()