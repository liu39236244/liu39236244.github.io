# mybatis进阶

## 了解进阶

## 商品数据模型分析

![](assets/009/03/01/03-1644204400050.png)


表与表之间的业务关系．
在分析表与表之间的业务关系时需要建立在某个业务意义基础上去分祈。
先分析据级别之间有关系的表之间的业务关系：


usre和orders：
user---->orders：
orders--->user：
-个用户可以创建多个订单一对多
一个订单只由一个用户创建一对一

orders和orderdetail:
orders---》orderdetail : 一个订单可以包括多个订单明细因为一个订单可以购买多个商品，每个商品的购买信息
在orderdetail记录 一对多关系料

orderdetail 与 orders  ： 一个订单明细只能包括在一个订单中，一对一

orderdetail---》itesms： 一个订单明细只对应一个商品信息，一对一

items-->。rderdet一个商品可以包括在多个订单明细，一对多


## 04高级映射-一对一查询-使用resultType


### 1 sql 关联语句


![](assets/009/03/01/03-1644206296692.png)

pojo 创建

![](assets/009/03/01/03-1644212812768.png)

### 2 mapper.xml

![](assets/009/03/01/03-1644212932071.png)


### 3 mapper.java


![](assets/009/03/01/03-1644220838840.png)



## 05高级映射-一对一查询-使用resultMap


映射到 order 对象中 user属性 


### order 属性中加入user 属性

![](assets/009/03/01/03-1644221184385.png)

### 定义一个resultMap

将整个查询结果映射到orders 中 ，首先创建

![](assets/009/03/01/03-1644224445044.png)

### 定义一个statment 也就是 xml 的写法

![](assets/009/03/01/03-1644224530943.png)


### 定义maper.java 

![](assets/009/03/01/03-1644224604023.png)


### 测试

![](assets/009/03/01/03-1644224649353.png)


### resultMap 与 resultType 一对一的区别

![](assets/009/03/01/03-1644225725077.png)


## 一对多

### 需求

查询订单以及订单详情信息

### sql 语句 


主表：订单表

关联表：订单明细表

一对一的基础之上添加订单明细

![](assets/009/03/01/03-1644226885605.png)


![](assets/009/03/01/03-1644226255433.png)




### pojo添加订单详细属性list

![](assets/009/03/01/03-1644226300432.png)

### resultMap 定义


大体内容resultMap 架构

![](assets/009/03/01/03-1644226503414.png)


> 1 订单、用户 配置 

![](assets/009/03/01/03-1644226556683.png)

> 2 主要是订单详情定义

![](assets/009/03/01/03-1644227126782.png)


> 3 优化，可以重复的定义使用继承即可

![](assets/009/03/01/03-1644227255514.png)

### xml 定义



![](assets/009/03/01/03-1644226946043.png)


### mapper.java 接口


![](assets/009/03/01/03-1644227308524.png)


### 总结 

![](assets/009/03/01/03-1644227531361.png)


所以resultType 还得加上java逻辑 肯定不好用，所以这种情况用resultMap 

## 多对多


### 需求

查询用户以及用户购买的商品信息

### 分析

查询主表：用户表

关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表：
orders、 orderdetail、items

### sql


![](assets/009/03/01/03-1644227839285.png)


### 映射思路


![](assets/009/03/01/03-1644228020194.png)


### user对象中添加订单list 


![](assets/009/03/01/03-1644228415698.png)

### mapper.xml



### resultMap定义 

![](assets/009/03/01/03-1644228790625.png)
![](assets/009/03/01/03-1644228851223.png)

### mapper.java 定义

![](assets/009/03/01/03-1644228897492.png)


### 多对多查询总结

![](assets/009/03/01/03-1644229280015.png)

## 总的resultMap 的总结 resultType总结

### resultType 

![](assets/009/03/01/03-1644229392654.png)


### resultMap

![](assets/009/03/01/03-1644229482614.png)


### collection 


![](assets/009/03/01/03-1644229616228.png)

场合

![](assets/009/03/01/03-1644229653303.png)


## 延迟加载


### 概念


### order查询的xml

![](assets/009/03/01/03-1644231772797.png)


### 只查询用户信息

使用association中的select指定延迟加载去执行的statement的id


![](assets/009/03/01/03-1644232079759.png)

![](assets/009/03/01/03-1644232102397.png)


### 关联查询用户

![](assets/009/03/01/03-1644232138525.png)


![](assets/009/03/01/03-1644232205847.png)



### mapper.java 接口


![](assets/009/03/01/03-1644232267568.png)



### 测试思路


![](assets/009/03/01/03-1644232386225.png)


### mybatis延迟加载配置

![](assets/009/03/01/03-1644232411007.png)


> 1 延迟加载开关以及积极消极加载

![](assets/009/03/01/03-1644232496768.png)


### 测代码

![](assets/009/03/01/03-1644232631297.png)


### 不适用assocication 实现延迟加载

![](assets/009/03/01/03-1644232784817.png)


## 一级缓存


### 介绍

mybatis提供查询缓存，用于减轻数据库压力，提高数据库性能。

mybatis默认是开启一级缓存的，不需要去配置

mybatis 提供一级缓存，和二级缓存


![](assets/009/03/01/03-1644233011127.png)


![](assets/009/03/01/03-1644240431340.png)


![](assets/009/03/01/03-1644240503959.png)

![](assets/009/03/01/03-1644240669368.png)



### 一级缓存测试


![](assets/009/03/01/03-1644240890148.png)


> 1 执行增删改查然后  commit操作 以后会清空缓存


![](assets/009/03/01/03-1644241149721.png)


### 一级缓存应用


默认是没有开启的

![](assets/009/03/01/03-1644241681399.png)

## 二级缓存


![](assets/009/03/01/03-1644241727630.png)


![](assets/009/03/01/03-1644241973100.png)


![](assets/009/03/01/03-1644242008200.png)


### 开启二级缓存 


mybatis 的二级缓存是mapper 范围级别，除了在sqlMapConfig.xml 设置二级缓存的总开关，还要在具体的mapper.xml 中开启二级缓存


![](assets/009/03/01/03-1644242190075.png)


在UserMapper.xml中开启二级缓存，UserMapper.xml 下的sql执行完成会存储到他的魂村区域（hashMap）
然后在需要开启二级缓存的mapper中添加标签开启二级缓存

![](assets/009/03/01/03-1644242301459.png)


#### 注意pojo一定要实现序列化接口

为了将魂村数据去处执行反序列化操作，因为二级缓存数据存储介质多种多哟昂，不一定在内存中

![](assets/009/03/01/03-1644242419836.png)


### 测试二级魂村


![](assets/009/03/01/03-1644242558025.png)

#### 注意缓命中率的启动打印日志


![](assets/009/03/01/03-1644242629290.png)

说明魂村命中率为0 ；缓存中没有能使用的对象

![](assets/009/03/01/03-1644242668810.png)

第二次从缓存中找，找到了 找了两次找到一次 就是 0.5 的命中率

#### sqlSession3 操作数据清空二级缓存

![](assets/009/03/01/03-1644242799009.png)

### 禁用二级缓存 useCache 默认为true


![](assets/009/03/01/03-1644242902912.png) 


### 刷新缓存(就是清空缓存)

![](assets/009/03/01/03-1644243089369.png)


![](assets/009/03/01/03-1644243107139.png)


总结：一般下执行完commit 操作都需要刷新缓存，flushCache=true 表示刷新缓存，这样可以避免数据库脏读。

就是，即使sqlsession3 进行了commit 的操作； xml 中 设置了 flushCache=false ，那么 **commit也不会清空缓存，依然从二级缓存中去取**




### mybatis 刷新间隔

![](assets/009/03/01/03-1644243400659.png)



## mybatis整合 ehcache

ehcache是一个分布式的缓存框架



### 分布式缓存

提高系统并发，对系统进行分布式部署(集群部署方法) 

![](assets/009/03/01/03-1644243812281.png)

如果不使用分布式缓存，缓存的数据在各个服务单独存储，不方便系统开发，所以要用分布式缓存对缓存数据进行集中管理

* 所以这也说明了mybatis 不能进行分布式缓存



### 整合ehcache


![](assets/009/03/01/03-1644243986779.png)


### mybatis默认实现cache类

![](assets/009/03/01/03-1644244063091.png)


![](assets/009/03/01/03-1644244180640.png)


#### 引入jar

![](assets/009/03/01/03-1644244234520.png)


#### 指定 ehcache 类

![](assets/009/03/01/03-1644244295890.png)

#### 引入ehcache 配置文件


![](assets/009/03/01/03-1644244346303.png)


## 二级缓存应用场景

![](assets/009/03/01/03-1644244597630.png)


## 局限性

![](assets/009/03/01/03-1644244608861.png)

因为一个命名空间中的如果有一个商品或者一个用户修改了内容，那么将会清空mapper中所有商品或者所有用户的信息，缓存命中率很低；所以不够细粒度，如果想腰细粒度的缓存；那么就是咱们常说的三级缓存，自己手动实现某一业务逻辑的缓存。三级缓存只是概念上的！ 至少mybatis 实现不了





## 16 16mybatis和spring整合-sqlSessionFactory配置