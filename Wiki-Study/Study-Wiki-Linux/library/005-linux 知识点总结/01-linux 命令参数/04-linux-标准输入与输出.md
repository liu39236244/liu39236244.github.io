# linux 的标准输入与输出

## 标准输入与输出
原文地址:https://blog.csdn.net/u012656834/article/details/41310237

```
Linux环境中支持输入输出重定向，用符号<和>来表示。
0、1和2分别表示标准输入、标准输出和标准错误信息输出，可以用来指定需要重定向的标准输入或输出，比如 2>lee.dat 表示将错误信息输出到文件lee.dat中。
同时，还可以在这三个标准输入输出之间实现重定向，比如将错误信息重定向到标准输出，可以用 2>&1来实现。
Linux下还有一个特殊的文件/dev/null，它就像一个无底洞，所有重定向到它的信息都会消失得无影无踪。这一点非常有用，当我们不需要回显程序的所有信息时，就可以将输出重定向到/dev/null。
如果想要正常输出和错误信息都不显示，则要把标准输出和标准错误都重定向到/dev/null， 例如：
# ls 1>/dev/null 2>/dev/null
还有一种做法是将错误重定向到标准输出，然后再重定向到 /dev/null，例如：
# ls >/dev/null 2>&1
注意：此处的顺序不能更改，否则达不到想要的效果，此时先将标准输出重定向到 /dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null。
1. 标准输入的控制
语法：命令< 文件将文件做为命令的输入。
例如：
mail -s "mail lee” lee@lee.com < lee1 将文件lee1 当做信件的内容，主题名称为mail lee，送给收信人。
2. 标准输出的控制
语法：命令> 文件
将命令的执行结果送至指定的文件中。
例如:
ls -l > lee.dat 将执行"ls -l"命令的结果写入文件 lee.dat 中。
语法：命令>! 文件
将命令的执行结果送至指定的文件中，若文件已经存在，则覆盖。
例如：
ls -lg >! lee.dat 将执行"ls -lg"命令的结果覆盖写入文件 lee.dat 中。
语法：命令>& 文件
将命令执行时屏幕上所产生的任何信息写入指定的文件中。
例如：
cc lee.c >& lee.dat 将编译 lee.c 文件时所产生的任何信息写入文件 lee.dat 中。

语法：命令>> 文件
将命令执行的结果附加到指定的文件中。
例如:
ls -lag >> lee.dat 将执行 "ls -lag" 命令的结果附加到文件 lee.dat 中。

语法：命令>>& 文件
将命令执行时屏幕上所产生的任何信息附加到指定的文件中。
例如:
cc lee.c >& lee.dat 将编译 lee.c 文件时屏幕所产生的任何信息附加到文件 lee.dat 中。

在字符终端环境中，标准输入/标准输出的概念很好理解。输入即指对一个应用程序或命令的输入，无论是从键盘输入还是从别的文件输入；输出即指应用程序或命令产生的一些信息；与 Windows 系统下不同的是，Linux 系统下还有一个标准错误输出的概念，这个概念主要是为程序调试和系统维护目的而设置的，错误输出于标准输出分开可以让一些高级的错误信息不干扰正常的输出信息，从而方便一般用户的使用。
在 Linux 系统中：标准输入(stdin)默认为键盘输入；标准输出(stdout)默认为屏幕输出；标准错误输出(stderr)默认也是输出到屏幕（上面的 std 表示 standard）。在 BASH 中使用这些概念时一般将标准输出表示为 1，将标准错误输出表示为 2。下面我们举例来说明如何使用他们，特别是标准输出和标准错误输出。
输入、输出及标准错误输出主要用于 I/O 的重定向，就是说需要改变他们的默认设置。先看这个例子：
$ ls > lee.dat
$ ls -l >> lee.dat
上面这两个命令分别将 ls 命令的结果输出重定向到 lee.dat 文件中和追加到 lee.dat 文件中，而不是输出到屏幕上。">"就是输出（标准输出和标准错误输出）重定向的代表符号，连续两个 ">" 符号，即 ">>" 则表示不清除原来的而追加输出。下面再来看一个稍微复杂的例子：
$ find /home -name lee* 2> err_lee
这个命令在 ">" 符号之前多了一个 "2"，"2>" 表示将标准错误输出重定向。由于 /home 目录下有些目录由于权限限制不能访问，因此会产生一些标准错误输出被存放在 err_result 文件中。大家可以设想一下 find /home -name lee* 2>>err_result 命令会产生什么结果？
如果直接执行 find /home -name lee* > all_lee ，其结果是只有标准输出被存入 all_lee 文件中，要想让标准错误输出和标准输入一样都被存入到文件中，那该怎么办呢？看下面这个例子：
$ find /home -name lee* > all_lee 2>& 1
上面这个例子中将首先将标准错误输出也重定向到标准输出中，再将标准输出重定向到 all_lee 这个文件中。这样我们就可以将所有的输出都存储到文件中了。为实现上述功能，还有一种简便的写法如下：
$ find /home -name lee* >& all_lee
如果那些出错信息并不重要，下面这个命令可以让你避开众多无用出错信息的干扰：
$ find /home -name lee* 2> /dev/null
同学们回去后还可以再试验一下如下几种重定向方式，看看会出什么结果，为什么？
$ find /home -name lee* > all_lee 1>& 2
$ find /home -name lee* 2> all_lee 1>& 2
$ find /home -name lee* 2>& 1 > all_lee
外一个非常有用的重定向操作符是 "-"，请看下面这个例子：
$ (cd /source/lee && tar cf - . ) | (cd /dest/lee && tar xvfp -)
该命令表示把 /source/lee 目录下的所有文件通过压缩和解压，快速的全部移动到 /dest/lee 目录下去，这个命令在 /source/lee 和 /dest/lee 不处在同一个文件系统下时将显示出特别的优势。
下面还几种不常见的用法：
n<&- 表示将 n 号输入关闭
<&- 表示关闭标准输入（键盘）
n>&- 表示将 n 号输出关闭
>&- 表示将标准输出关闭
再给大家一个很有用的命令：
grep lee `find . 2>/dev/null|grep sh$`


```
